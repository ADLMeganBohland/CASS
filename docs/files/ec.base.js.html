<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>ec.base.js - CASS Javascript Library</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="http://www.cassproject.org/_/rsrc/1451948061999/config/customLogo.gif?revision=16" title="CASS Javascript Library"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Action.html">Action</a></li>
                                <li><a href="../classes/AlignmentObject.html">AlignmentObject</a></li>
                                <li><a href="../classes/CreativeWork.html">CreativeWork</a></li>
                                <li><a href="../classes/Ebac.html">Ebac</a></li>
                                <li><a href="../classes/EcAes.html">EcAes</a></li>
                                <li><a href="../classes/EcAesCtr.html">EcAesCtr</a></li>
                                <li><a href="../classes/EcAesCtrAsync.html">EcAesCtrAsync</a></li>
                                <li><a href="../classes/EcArray.html">EcArray</a></li>
                                <li><a href="../classes/EcAsyncHelper.html">EcAsyncHelper</a></li>
                                <li><a href="../classes/EcDirectedGraph.html">EcDirectedGraph</a></li>
                                <li><a href="../classes/EcLinkedData.html">EcLinkedData</a></li>
                                <li><a href="../classes/EcObject.html">EcObject</a></li>
                                <li><a href="../classes/EcPk.html">EcPk</a></li>
                                <li><a href="../classes/EcPpk.html">EcPpk</a></li>
                                <li><a href="../classes/EcRemote.html">EcRemote</a></li>
                                <li><a href="../classes/EcRemoteLinkedData.html">EcRemoteLinkedData</a></li>
                                <li><a href="../classes/EcRsaOaep.html">EcRsaOaep</a></li>
                                <li><a href="../classes/EcRsaOaepAsync.html">EcRsaOaepAsync</a></li>
                                <li><a href="../classes/General.html">General</a></li>
                                <li><a href="../classes/Graph.html">Graph</a></li>
                                <li><a href="../classes/Hypergraph.html">Hypergraph</a></li>
                                <li><a href="../classes/Person.html">Person</a></li>
                                <li><a href="../classes/Triple.html">Triple</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: ec.base.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
 Copyright 2015-2016 Eduworks Corporation and other contributing parties.

 Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
*/
/**
 *  Object to hold a triple, used in graph.
 *  @class Triple
 *  @author fritz.ray@eduworks.com
 */
var Triple = function() {};
Triple = stjs.extend(Triple, null, [], function(constructor, prototype) {
    /**
     *  Source vertex.
     *  @property source
     *  @type any
     */
    prototype.source = null;
    /**
     *  Destination vertex.
     *  @property destination
     *  @type any
     */
    prototype.destination = null;
    /**
     *  Object to hold in the edge.
     *  @property edge
     *  @type any
     */
    prototype.edge = null;
    /**
     *  Returns true IFF sources, destinations, and edges match.
     *  @method equals
     *  @param {Edge} obj
     *  @return {boolean} true IFF &lt;see method definition&gt;
     */
    prototype.equals = function(obj) {
        if (Object.prototype.equals.call(this, obj)) 
            return true;
        if (stjs.isInstanceOf(obj.constructor, Triple)) {
            var t = obj;
            if (this.source.equals(t.source) &amp;&amp; this.destination.equals(t.destination) &amp;&amp; this.edge.equals(t.edge)) 
                return true;
        }
        return false;
    };
}, {}, {});
/**
 *  Object Helper Functions
 *  @class EcObject
 *  @author fritz.ray@eduworks.com
 */
var EcObject = function() {};
EcObject = stjs.extend(EcObject, null, [], function(constructor, prototype) {
    /**
     *  Returns true if the result is an object.
     *  @static
     *  @method isArray
     *  @param {any} o Object to test.
     *  @return true iff the object is an object.
     */
    constructor.isObject = function(o) {
        return (typeof o) == &quot;object&quot;;
    };
}, {}, {});
/**
 *  Array Helper Functions
 *  @class EcArray
 *  @author fritz.ray@eduworks.com
 */
var EcArray = function() {};
EcArray = stjs.extend(EcArray, null, [], function(constructor, prototype) {
    /**
     *  Returns true if the result is an array.
     *  @static
     *  @method isArray
     *  @param {any} o Object to test.
     *  @return true iff the object is an array.
     */
    constructor.isArray = function(o) {
        return toString.call(o) == &quot;[object Array]&quot;;
    };
    /**
     *  Removes values IFF the values == one another.
     *  @static
     *  @method removeDuplicates
     *  @param a {Array} Array to remove duplicates from.
     */
    constructor.removeDuplicates = function(a) {
        for (var i = 0; i &lt; a.length; i++) 
            for (var j = i; j &lt; a.length; j++) {
                if (j == i) 
                    continue;
                if (a[i] == a[j]) 
                    a.splice(j, 1);
            }
    };
}, {}, {});
/**
 *  Pattern (probably similar to Promise) that provides fine grained control over asynchronous execution.
 *  Will iterate over all items in an array and perform &#x27;each(item,callback)&#x27;. 
 *  Every &#x27;each&#x27; needs to call the callback. This callback can be passed down through several asynchronous calls. 
 *  When all callbacks have been called, &#x27;after(array)&#x27; is called. 
 *  @author fritz.ray@eduworks.com
 *  @class EcAsyncHelper
 */
var EcAsyncHelper = function() {};
EcAsyncHelper = stjs.extend(EcAsyncHelper, null, [], function(constructor, prototype) {
    constructor.scriptPath = null;
    /**
     *  Counter that counts down when each callback is called. Lots of tricks can be done to cause after to proc in different ways.
     *  @property counter
     *  @type integer
     */
    prototype.counter = null;
    /**
     *  &quot;Each&quot; method. See class description.
     *  @method each
     *  @param {Array} array Array to iterate over.
     *  @param {function(item,callback)} each Method that gets invoked per item in the array.
     *  @param {function(array)} after Method invoked when all callbacks are called.
     */
    prototype.each = function(array, each, after) {
        var me = this;
        this.counter = array.length;
        if (array.length == 0) 
            after(array);
        for (var i = 0; i &lt; array.length; i++) {
            if (this.counter &gt; 0) 
                each(array[i], function() {
                    me.counter--;
                    if (me.counter == 0) 
                        after(array);
                });
        }
    };
    /**
     *  Will prevent &#x27;after&#x27; from being called.
     *  @method stop
     */
    prototype.stop = function() {
        this.counter = -1;
    };
}, {}, {});
/**
 *  A hypergraph, consisting of a set of vertices of type &lt;code&gt;V&lt;/code&gt; and a
 *  set of hyperedges of type &lt;code&gt;E&lt;/code&gt; which connect the vertices. This is
 *  the base interface for all JUNG graph types.
 *  &lt;P&gt;
 *  This interface permits, but does not enforce, any of the following common
 *  variations of graphs:
 *  &lt;ul&gt;
 *  &lt;li/&gt;hyperedges (edges which connect a set of vertices of any size)
 *  &lt;li/&gt;edges (these have have exactly two endpoints, which may or may not be
 *  distinct)
 *  &lt;li/&gt;self-loops (edges which connect exactly one vertex)
 *  &lt;li&gt;directed and undirected edges
 *  &lt;li&gt;vertices and edges with attributes (for example, weighted edges)
 *  &lt;li&gt;vertices and edges with different constraints or properties (for example,
 *  bipartite or multimodal graphs)
 *  &lt;li&gt;parallel edges (multiple edges which connect a single set of vertices)
 *  &lt;li&gt;internal representations as matrices or as adjacency lists or adjacency
 *  maps
 *  &lt;/ul&gt;
 *  Extensions or implementations of this interface may enforce or disallow any
 *  or all of these variations.
 *  &lt;p&gt;
 *  &lt;b&gt;Notes&lt;/b&gt;:
 *  &lt;ul&gt;
 *  &lt;li/&gt;The collections returned by &lt;code&gt;Hypergraph&lt;/code&gt; instances should be
 *  treated in general as if read-only. While they are not contractually
 *  guaranteed (or required) to be immutable, this interface does not define the
 *  outcome if they are mutated. Mutations should be done via
 *  &lt;code&gt;{add,remove}{Edge,Vertex}&lt;/code&gt;, or in the constructor.
 *  &lt;li/&gt;
 *  &lt;/ul&gt;
 *  
 *  @class Hypergraph
 *  @author Joshua O&#x27;Madadhain
 *   
 *  Ported to Javascript by:
 *  @author Fritz Ray (Eduworks)
 *  @author Tom Buskirk (Eduworks)
 */
var Hypergraph = function() {};
Hypergraph = stjs.extend(Hypergraph, null, [], function(constructor, prototype) {
    /**
     *  Returns a view of all edges in this graph. In general, this obeys the
     *  &lt;code&gt;Array&lt;/code&gt; contract, and therefore makes no guarantees about the
     *  ordering of the vertices within the set.
     *  
     *  @method getEdges
     *  @return a &lt;code&gt;Array&lt;/code&gt; view of all edges in this graph
     */
    prototype.getEdges = function() {};
    /**
     *  Returns a view of all vertices in this graph. In general, this obeys the
     *  &lt;code&gt;Array&lt;/code&gt; contract, and therefore makes no guarantees about the
     *  ordering of the vertices within the set.
     *  
     *  @method getVerticies
     *  @return a &lt;code&gt;Array&lt;/code&gt; view of all vertices in this graph
     */
    prototype.getVertices = function() {};
    /**
     *  Returns true if this graph&#x27;s vertex collection contains
     *  &lt;code&gt;vertex&lt;/code&gt;. Equivalent to
     *  &lt;code&gt;getVertices().contains(vertex)&lt;/code&gt;.
     *  
     *  @method containsVertex
     *  @param vertex
     *             the vertex whose presence is being queried
     *  @return true iff this graph contains a vertex &lt;code&gt;vertex&lt;/code&gt;
     */
    prototype.containsVertex = function(vertex) {};
    /**
     *  Returns true if this graph&#x27;s edge collection contains &lt;code&gt;edge&lt;/code&gt;.
     *  Equivalent to &lt;code&gt;getEdges().contains(edge)&lt;/code&gt;.
     *  
     *  @method containsEdge
     *  @param edge
     *             the edge whose presence is being queried
     *  @return true iff this graph contains an edge &lt;code&gt;edge&lt;/code&gt;
     */
    prototype.containsEdge = function(edge) {};
    /**
     *  Returns the number of edges in this graph.
     *  
     *  @method getEdgeCount
     *  @return the number of edges in this graph
     */
    prototype.getEdgeCount = function() {};
    /**
     *  Returns the number of vertices in this graph.
     *  
     *  @method getVertexCount
     *  @return the number of vertices in this graph
     */
    prototype.getVertexCount = function() {};
    /**
     *  Returns the collection of vertices which are connected to
     *  &lt;code&gt;vertex&lt;/code&gt; via any edges in this graph. If &lt;code&gt;vertex&lt;/code&gt;
     *  is connected to itself with a self-loop, then it will be included in the
     *  collection returned.
     *  
     *  @method getNeighbors
     *  @param vertex
     *             the vertex whose neighbors are to be returned
     *  @return the collection of vertices which are connected to
     *          &lt;code&gt;vertex&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;vertex&lt;/code&gt;
     *          is not present
     */
    prototype.getNeighbors = function(vertex) {};
    /**
     *  Returns the collection of edges in this graph which are connected to
     *  &lt;code&gt;vertex&lt;/code&gt;.
     *  
     *  @method getIncidentEdges
     *  @param vertex
     *             the vertex whose incident edges are to be returned
     *  @return the collection of edges which are connected to
     *          &lt;code&gt;vertex&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;vertex&lt;/code&gt;
     *          is not present
     */
    prototype.getIncidentEdges = function(vertex) {};
    /**
     *  Returns the collection of vertices in this graph which are connected to
     *  &lt;code&gt;edge&lt;/code&gt;. Note that for some graph types there are guarantees
     *  about the size of this collection (i.e., some graphs contain edges that
     *  have exactly two endpoints, which may or may not be distinct).
     *  Implementations for those graph types may provide alternate methods that
     *  provide more convenient access to the vertices.
     *  
     *  @method getIncidentVertices
     *  @param edge
     *             the edge whose incident vertices are to be returned
     *  @return the collection of vertices which are connected to
     *          &lt;code&gt;edge&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;edge&lt;/code&gt; is
     *          not present
     */
    prototype.getIncidentVertices = function(edge) {};
    /**
     *  Returns an edge that connects this vertex to &lt;code&gt;v&lt;/code&gt;. If this edge
     *  is not uniquely defined (that is, if the graph contains more than one
     *  edge connecting &lt;code&gt;v1&lt;/code&gt; to &lt;code&gt;v2&lt;/code&gt;), any of these edges
     *  may be returned. &lt;code&gt;findEdgeSet(v1, v2)&lt;/code&gt; may be used to return
     *  all such edges. Returns null if either of the following is true:
     *  &lt;ul&gt;
     *  &lt;li/&gt;&lt;code&gt;v2&lt;/code&gt; is not connected to &lt;code&gt;v1&lt;/code&gt;
     *  &lt;li/&gt;either &lt;code&gt;v1&lt;/code&gt; or &lt;code&gt;v2&lt;/code&gt; are not present in this
     *  graph
     *  &lt;/ul&gt;
     *  &lt;p&gt;
     *  &lt;b&gt;Note&lt;/b&gt;: for purposes of this method, &lt;code&gt;v1&lt;/code&gt; is only
     *  considered to be connected to &lt;code&gt;v2&lt;/code&gt; via a given &lt;i&gt;directed&lt;/i&gt;
     *  edge &lt;code&gt;e&lt;/code&gt; if
     *  &lt;code&gt;v1 == e.getSource() &amp;&amp; v2 == e.getDest()&lt;/code&gt; evaluates to
     *  &lt;code&gt;true&lt;/code&gt;. (&lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt; are connected by
     *  an undirected edge &lt;code&gt;u&lt;/code&gt; if &lt;code&gt;u&lt;/code&gt; is incident to both
     *  &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt;.)
     *  
     *  @method findEdge
     *  @param v1 between this
     *  @param v2 and that
     *  @return an edge that connects &lt;code&gt;v1&lt;/code&gt; to &lt;code&gt;v2&lt;/code&gt;, or
     *          &lt;code&gt;null&lt;/code&gt; if no such edge exists (or either vertex is not
     *          present)
     *  @see Hypergraph#findEdgeSet(Object, Object)
     */
    prototype.findEdge = function(v1, v2) {};
    /**
     *  Returns all edges that connects this vertex to &lt;code&gt;v&lt;/code&gt;. If this
     *  edge is not uniquely defined (that is, if the graph contains more than
     *  one edge connecting &lt;code&gt;v1&lt;/code&gt; to &lt;code&gt;v2&lt;/code&gt;), any of these
     *  edges may be returned. &lt;code&gt;findEdgeSet(v1, v2)&lt;/code&gt; may be used to
     *  return all such edges. Returns null if &lt;code&gt;v2&lt;/code&gt; is not connected
     *  to &lt;code&gt;v1&lt;/code&gt;. &lt;br/&gt;
     *  Returns an empty collection if either &lt;code&gt;v1&lt;/code&gt; or &lt;code&gt;v2&lt;/code&gt;
     *  are not present in this graph.
     *  
     *  &lt;p&gt;
     *  &lt;b&gt;Note&lt;/b&gt;: for purposes of this method, &lt;code&gt;v1&lt;/code&gt; is only
     *  considered to be connected to &lt;code&gt;v2&lt;/code&gt; via a given &lt;i&gt;directed&lt;/i&gt;
     *  edge &lt;code&gt;d&lt;/code&gt; if
     *  &lt;code&gt;v1 == d.getSource() &amp;&amp; v2 == d.getDest()&lt;/code&gt; evaluates to
     *  &lt;code&gt;true&lt;/code&gt;. (&lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt; are connected by
     *  an undirected edge &lt;code&gt;u&lt;/code&gt; if &lt;code&gt;u&lt;/code&gt; is incident to both
     *  &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt;.)
     *  
     *  @method findEdgeSet
     *  @param v1 between this
     *  @param v2 and that
     *  @return a collection containing all edges that connect &lt;code&gt;v1&lt;/code&gt; to
     *          &lt;code&gt;v2&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if either vertex is not
     *          present
     *  @see Hypergraph#findEdge(Object, Object)
     */
    prototype.findEdgeSet = function(v1, v2) {};
    /**
     *  Adds &lt;code&gt;vertex&lt;/code&gt; to this graph. Fails if &lt;code&gt;vertex&lt;/code&gt; is
     *  null or already in the graph.
     *  
     *  @method addVertex
     *  @param vertex
     *             the vertex to add
     *  @return &lt;code&gt;true&lt;/code&gt; if the add is successful, and
     *          &lt;code&gt;false&lt;/code&gt; otherwise
     *  @throws IllegalArgumentException
     *              if &lt;code&gt;vertex&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     */
    prototype.addVertex = function(vertex) {};
    /**
     *  Adds &lt;code&gt;edge&lt;/code&gt; to this graph. Fails under the following
     *  circumstances:
     *  &lt;ul&gt;
     *  &lt;li/&gt;&lt;code&gt;edge&lt;/code&gt; is already an element of the graph
     *  &lt;li/&gt;either &lt;code&gt;edge&lt;/code&gt; or &lt;code&gt;vertices&lt;/code&gt; is
     *  &lt;code&gt;null&lt;/code&gt;
     *  &lt;li/&gt;&lt;code&gt;vertices&lt;/code&gt; has the wrong number of vertices for the graph
     *  type
     *  &lt;li/&gt;&lt;code&gt;vertices&lt;/code&gt; are already connected by another edge in this
     *  graph, and this graph does not accept parallel edges
     *  &lt;/ul&gt;
     *  
     *  @method addHyperEdge
     *  @param edge
     *  @param vertices
     *  @return &lt;code&gt;true&lt;/code&gt; if the add is successful, and
     *          &lt;code&gt;false&lt;/code&gt; otherwise
     *  @throws IllegalArgumentException
     *              if &lt;code&gt;edge&lt;/code&gt; or &lt;code&gt;vertices&lt;/code&gt; is null, or if
     *              a different vertex set in this graph is already connected by
     *              &lt;code&gt;edge&lt;/code&gt;, or if &lt;code&gt;vertices&lt;/code&gt; are not a
     *              legal vertex set for &lt;code&gt;edge&lt;/code&gt;
     */
    prototype.addHyperEdge = function(edge, vertices) {};
    /**
     *  Removes &lt;code&gt;vertex&lt;/code&gt; from this graph. As a side effect, removes
     *  any edges &lt;code&gt;e&lt;/code&gt; incident to &lt;code&gt;vertex&lt;/code&gt; if the removal
     *  of &lt;code&gt;vertex&lt;/code&gt; would cause &lt;code&gt;e&lt;/code&gt; to be incident to an
     *  illegal number of vertices. (Thus, for example, incident hyperedges are
     *  not removed, but incident edges--which must be connected to a vertex at
     *  both endpoints--are removed.)
     *  
     *  &lt;p&gt;
     *  Fails under the following circumstances:
     *  &lt;ul&gt;
     *  &lt;li/&gt;&lt;code&gt;vertex&lt;/code&gt; is not an element of this graph
     *  &lt;li/&gt;&lt;code&gt;vertex&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     *  &lt;/ul&gt;
     *  
     *  @method removeVertex
     *  @param vertex
     *             the vertex to remove
     *  @return &lt;code&gt;true&lt;/code&gt; if the removal is successful,
     *          &lt;code&gt;false&lt;/code&gt; otherwise
     */
    prototype.removeVertex = function(vertex) {};
    /**
     *  Removes &lt;code&gt;edge&lt;/code&gt; from this graph. Fails if &lt;code&gt;edge&lt;/code&gt; is
     *  null, or is otherwise not an element of this graph.
     *  
     *  @method removeEdge
     *  @param edge
     *             the edge to remove
     *  @return &lt;code&gt;true&lt;/code&gt; if the removal is successful,
     *          &lt;code&gt;false&lt;/code&gt; otherwise
     */
    prototype.removeEdge = function(edge) {};
    /**
     *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt; share an
     *  incident edge. Equivalent to &lt;code&gt;getNeighbors(v1).contains(v2)&lt;/code&gt;.
     *  
     *  @method isNeighbor
     *  @param v1
     *             the first vertex to test
     *  @param v2
     *             the second vertex to test
     *  @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt; share an
     *          incident edge
     */
    prototype.isNeighbor = function(v1, v2) {};
    /**
     *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;vertex&lt;/code&gt; and &lt;code&gt;edge&lt;/code&gt;
     *  are incident to each other. Equivalent to
     *  &lt;code&gt;getIncidentEdges(vertex).contains(edge)&lt;/code&gt; and to
     *  &lt;code&gt;getIncidentVertices(edge).contains(vertex)&lt;/code&gt;.
     *  
     *  @method isIncident
     *  @param vertex
     *  @param edge
     *  @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;vertex&lt;/code&gt; and &lt;code&gt;edge&lt;/code&gt;
     *          are incident to each other
     */
    prototype.isIncident = function(vertex, edge) {};
    /**
     *  Returns the number of edges incident to &lt;code&gt;vertex&lt;/code&gt;. Special
     *  cases of interest:
     *  &lt;ul&gt;
     *  &lt;li/&gt;Incident self-loops are counted once.
     *  &lt;li&gt;If there is only one edge that connects this vertex to each of its
     *  neighbors (and vice versa), then the value returned will also be equal to
     *  the number of neighbors that this vertex has (that is, the output of
     *  &lt;code&gt;getNeighborCount&lt;/code&gt;).
     *  &lt;li&gt;If the graph is directed, then the value returned will be the sum of
     *  this vertex&#x27;s indegree (the number of edges whose destination is this
     *  vertex) and its outdegree (the number of edges whose source is this
     *  vertex), minus the number of incident self-loops (to avoid
     *  double-counting).
     *  &lt;/ul&gt;
     *  &lt;p&gt;
     *  Equivalent to &lt;code&gt;getIncidentEdges(vertex).size()&lt;/code&gt;.
     *  
     *  @method degree
     *  @param vertex
     *             the vertex whose degree is to be returned
     *  @return the degree of this node
     *  @see Hypergraph#getNeighborCount(Object)
     */
    prototype.degree = function(vertex) {};
    /**
     *  Returns the number of vertices that are adjacent to &lt;code&gt;vertex&lt;/code&gt;
     *  (that is, the number of vertices that are incident to edges in
     *  &lt;code&gt;vertex&lt;/code&gt;&#x27;s incident edge set).
     *  
     *  &lt;p&gt;
     *  Equivalent to &lt;code&gt;getNeighbors(vertex).size()&lt;/code&gt;.
     *  
     *  @method getNeighborCount
     *  @param vertex
     *             the vertex whose neighbor count is to be returned
     *  @return the number of neighboring vertices
     */
    prototype.getNeighborCount = function(vertex) {};
    /**
     *  Returns the number of vertices that are incident to &lt;code&gt;edge&lt;/code&gt;.
     *  For hyperedges, this can be any nonnegative integer; for edges this must
     *  be 2 (or 1 if self-loops are permitted).
     *  
     *  &lt;p&gt;
     *  Equivalent to &lt;code&gt;getIncidentVertices(edge).size()&lt;/code&gt;.
     *  
     *  @method getIncidentCount
     *  @param edge
     *             the edge whose incident vertex count is to be returned
     *  @return the number of vertices that are incident to &lt;code&gt;edge&lt;/code&gt;.
     */
    prototype.getIncidentCount = function(edge) {};
    /**
     *  Returns the edge type of &lt;code&gt;edge&lt;/code&gt; in this graph.
     *  
     *  @method getEdgeType
     *  @param edge
     *  @return the &lt;code&gt;EdgeType&lt;/code&gt; of &lt;code&gt;edge&lt;/code&gt;, or
     *          &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;edge&lt;/code&gt; has no defined type
     */
    prototype.getEdgeType = function(edge) {};
    /**
     *  Returns the default edge type for this graph.
     *  
     *  @method getDefaultEdgeType
     *  @return the default edge type for this graph
     */
    prototype.getDefaultEdgeType = function() {};
    /**
     *  Returns the collection of edges in this graph which are of type
     *  &lt;code&gt;edge_type&lt;/code&gt;.
     *  
     *  @method getEdgesOfType
     *  @param edge_type
     *             the type of edges to be returned
     *  @return the collection of edges which are of type &lt;code&gt;edge_type&lt;/code&gt;,
     *          or &lt;code&gt;null&lt;/code&gt; if the graph does not accept edges of this
     *          type
     *  @see EdgeType
     */
    prototype.getEdgesOfType = function(edge_type) {};
    /**
     *  Returns the number of edges of type &lt;code&gt;edge_type&lt;/code&gt; in this graph.
     *  
     *  @method getEdgeCountOfType
     *  @param edge_type
     *             the type of edge for which the count is to be returned
     *  @return the number of edges of type &lt;code&gt;edge_type&lt;/code&gt; in this graph
     */
    prototype.getEdgeCountOfType = function(edge_type) {};
    /**
     *  Returns a &lt;code&gt;Array&lt;/code&gt; view of the incoming edges incident to
     *  &lt;code&gt;vertex&lt;/code&gt; in this graph.
     *  
     *  @method getInEdges
     *  @param vertex
     *             the vertex whose incoming edges are to be returned
     *  @return a &lt;code&gt;Array&lt;/code&gt; view of the incoming edges incident to
     *          &lt;code&gt;vertex&lt;/code&gt; in this graph
     */
    prototype.getInEdges = function(vertex) {};
    /**
     *  Returns a &lt;code&gt;Array&lt;/code&gt; view of the outgoing edges incident to
     *  &lt;code&gt;vertex&lt;/code&gt; in this graph.
     *  
     *  @method getOutEdges
     *  @param vertex
     *             the vertex whose outgoing edges are to be returned
     *  @return a &lt;code&gt;Array&lt;/code&gt; view of the outgoing edges incident to
     *          &lt;code&gt;vertex&lt;/code&gt; in this graph
     */
    prototype.getOutEdges = function(vertex) {};
    /**
     *  Returns the number of incoming edges incident to &lt;code&gt;vertex&lt;/code&gt;.
     *  Equivalent to &lt;code&gt;getInEdges(vertex).size()&lt;/code&gt;.
     *  
     *  @method inDegree
     *  @param vertex
     *             the vertex whose indegree is to be calculated
     *  @return the number of incoming edges incident to &lt;code&gt;vertex&lt;/code&gt;
     */
    prototype.inDegree = function(vertex) {};
    /**
     *  Returns the number of outgoing edges incident to &lt;code&gt;vertex&lt;/code&gt;.
     *  Equivalent to &lt;code&gt;getOutEdges(vertex).size()&lt;/code&gt;.
     *  
     *  @method outDegree
     *  @param vertex
     *             the vertex whose outdegree is to be calculated
     *  @return the number of outgoing edges incident to &lt;code&gt;vertex&lt;/code&gt;
     */
    prototype.outDegree = function(vertex) {};
    /**
     *  If &lt;code&gt;directed_edge&lt;/code&gt; is a directed edge in this graph, returns
     *  the source; otherwise returns &lt;code&gt;null&lt;/code&gt;. The source of a directed
     *  edge &lt;code&gt;d&lt;/code&gt; is defined to be the vertex for which &lt;code&gt;d&lt;/code&gt;
     *  is an outgoing edge. &lt;code&gt;directed_edge&lt;/code&gt; is guaranteed to be a
     *  directed edge if its &lt;code&gt;EdgeType&lt;/code&gt; is &lt;code&gt;DIRECTED&lt;/code&gt;.
     *  
     *  @method getSource
     *  @param directed_edge
     *  @return the source of &lt;code&gt;directed_edge&lt;/code&gt; if it is a directed edge
     *          in this graph, or &lt;code&gt;null&lt;/code&gt; otherwise
     */
    prototype.getSource = function(directed_edge) {};
    /**
     *  If &lt;code&gt;directed_edge&lt;/code&gt; is a directed edge in this graph, returns
     *  the destination; otherwise returns &lt;code&gt;null&lt;/code&gt;. The destination of
     *  a directed edge &lt;code&gt;d&lt;/code&gt; is defined to be the vertex incident to
     *  &lt;code&gt;d&lt;/code&gt; for which &lt;code&gt;d&lt;/code&gt; is an incoming edge.
     *  &lt;code&gt;directed_edge&lt;/code&gt; is guaranteed to be a directed edge if its
     *  &lt;code&gt;EdgeType&lt;/code&gt; is &lt;code&gt;DIRECTED&lt;/code&gt;.
     *  
     *  @method getDest
     *  @param directed_edge
     *  @return the destination of &lt;code&gt;directed_edge&lt;/code&gt; if it is a directed
     *          edge in this graph, or &lt;code&gt;null&lt;/code&gt; otherwise
     */
    prototype.getDest = function(directed_edge) {};
    /**
     *  Returns a &lt;code&gt;Array&lt;/code&gt; view of the predecessors of
     *  &lt;code&gt;vertex&lt;/code&gt; in this graph. A predecessor of &lt;code&gt;vertex&lt;/code&gt;
     *  is defined as a vertex &lt;code&gt;v&lt;/code&gt; which is connected to
     *  &lt;code&gt;vertex&lt;/code&gt; by an edge &lt;code&gt;e&lt;/code&gt;, where &lt;code&gt;e&lt;/code&gt; is an
     *  outgoing edge of &lt;code&gt;v&lt;/code&gt; and an incoming edge of
     *  &lt;code&gt;vertex&lt;/code&gt;.
     *  
     *  @method getPredecessors
     *  @param vertex
     *             the vertex whose predecessors are to be returned
     *  @return a &lt;code&gt;Array&lt;/code&gt; view of the predecessors of
     *          &lt;code&gt;vertex&lt;/code&gt; in this graph
     */
    prototype.getPredecessors = function(vertex) {};
    /**
     *  Returns a &lt;code&gt;Array&lt;/code&gt; view of the successors of
     *  &lt;code&gt;vertex&lt;/code&gt; in this graph. A successor of &lt;code&gt;vertex&lt;/code&gt; is
     *  defined as a vertex &lt;code&gt;v&lt;/code&gt; which is connected to
     *  &lt;code&gt;vertex&lt;/code&gt; by an edge &lt;code&gt;e&lt;/code&gt;, where &lt;code&gt;e&lt;/code&gt; is an
     *  incoming edge of &lt;code&gt;v&lt;/code&gt; and an outgoing edge of
     *  &lt;code&gt;vertex&lt;/code&gt;.
     *  
     *  @method getSuccessors
     *  @param vertex
     *             the vertex whose predecessors are to be returned
     *  @return a &lt;code&gt;Array&lt;/code&gt; view of the successors of
     *          &lt;code&gt;vertex&lt;/code&gt; in this graph
     */
    prototype.getSuccessors = function(vertex) {};
}, {}, {});
/**
 *  Wrapper to handle all remote web service invocations.
 *  @class EcRemote
 *  @author fritz.ray@eduworks.com
 *  @author devlin.junker@eduworks.com
 */
var EcRemote = function() {};
EcRemote = stjs.extend(EcRemote, null, [], function(constructor, prototype) {
    /**
     *  Turn this property off to cause all remote web service calls to be synchronous. Can be useful for test scripts, blocking calls, etc.
     *  @property async
     *  @static
     *  @type boolean
     */
    constructor.async = true;
    /**
     *  POSTs a request to a remote endpoint. 
     *  Composed of a server endpoint (root URL) and a service (service path).
     *  Sends form data as a multi-part mime request.
     *  @method postExpectingObject
     *  @static
     *  @param {string} server Protocol, hostname and path to the remote handler.
     *  @param {string} service Path to service to invoke.
     *  @param {FormData} fd Form data to send as multi-part mime.
     *  @param {function(object)} success Method that is invoked if the server responds with a success (per jQuery ajax)
     *  @param {function(string)} failure Method that is invoked if the server responds with an error (per jQuery ajax) or a non-200/300.
     */
    constructor.postExpectingObject = function(server, service, fd, success, failure) {
        EcRemote.postInner(server, service, fd, EcRemote.getSuccessJSONCallback(success, failure), EcRemote.getFailureCallback(failure));
    };
    /**
     *  POSTs a request to a remote endpoint. 
     *  Composed of a server endpoint (root URL) and a service (service path).
     *  Sends form data as a multi-part mime request.
     *  @method postExpectingString
     *  @static
     *  @param {string} server Protocol, hostname and path to the remote handler.
     *  @param {string} service Path to service to invoke.
     *  @param {FormData} fd Form data to send as multi-part mime.
     *  @param {function(string)} success Method that is invoked if the server responds with a success (per jQuery ajax)
     *  @param {function(string)} failure Method that is invoked if the server responds with an error (per jQuery ajax) or a non-200/300.
     */
    constructor.postExpectingString = function(server, service, fd, success, failure) {
        EcRemote.postInner(server, service, fd, EcRemote.getSuccessCallback(success, failure), EcRemote.getFailureCallback(failure));
    };
    constructor.postInner = function(server, service, fd, successCallback, failureCallback) {
        var url = server;
        if (!url.endsWith(&quot;/&quot;) &amp;&amp; service != null &amp;&amp; !&quot;&quot;.equals(service)) 
            url += &quot;/&quot;;
        if (service != null) 
            url += service;
        var p = {};
        p.method = &quot;POST&quot;;
        p.url = url;
        if ((fd)[&quot;_streams&quot;] != null) {
            var chunks = (fd)[&quot;_streams&quot;];
            var all = &quot;&quot;;
            for (var i = 0; i &lt; chunks.length; i++) {
                if ((typeof chunks[i]) == &quot;function&quot;) 
                    all = all + &quot;\r\n&quot;;
                 else 
                    all = all + chunks[i];
            }
            all = all + &quot;\r\n\r\n--&quot; + (fd)[&quot;_boundary&quot;] + &quot;--&quot;;
            p.headers = new Object();
            p.headers[&quot;Content-Type&quot;] = &quot;multipart/form-data; boundary=&quot; + (fd)[&quot;_boundary&quot;];
            p.data = all;
        } else {
            p.mimeType = &quot;multipart/form-data&quot;;
            p.data = fd;
        }
        (p)[&quot;contentType&quot;] = false;
        p.cache = false;
        p.async = EcRemote.async;
        p.processData = false;
        p.success = successCallback;
        p.error = failureCallback;
        EcRemote.upgradeHttpToHttps(p);
        $.ajax(p);
    };
    /**
     *  GETs something from a remote endpoint. 
     *  Composed of a server endpoint (root URL) and a service (service path).
     *  @method postExpectingString
     *  @static
     *  @param {string} server Protocol, hostname and path to the remote handler.
     *  @param {string} service Path to service to invoke.
     *  @param {function(object)} success Method that is invoked if the server responds with a success (per jQuery ajax)
     *  @param {function(string)} failure Method that is invoked if the server responds with an error (per jQuery ajax) or a non-200/300.
     */
    constructor.getExpectingObject = function(server, service, success, failure) {
        var url = server;
        if (!url.endsWith(&quot;/&quot;) &amp;&amp; service != null &amp;&amp; service.equals(&quot;&quot;)) 
            url += &quot;/&quot;;
        if (service != null) 
            url += service;
        var p = {};
        p.method = &quot;GET&quot;;
        p.url = url;
        p.cache = false;
        p.async = EcRemote.async;
        p.processData = false;
        p.dataType = &quot;json&quot;;
        p.success = EcRemote.getSuccessJSONCallback(success, failure);
        p.error = EcRemote.getFailureCallback(failure);
        EcRemote.upgradeHttpToHttps(p);
        $.ajax(p);
    };
    /**
     *  DELETEs something at a remote endpoint. 
     *  Composed of a server endpoint (root URL) and a service (service path).
     *  @method _delete
     *  @static
     *  @param {string} server Protocol, hostname and path to the remote handler.
     *  @param {string} service Path to service to invoke.
     *  @param {function(object)} success Method that is invoked if the server responds with a success (per jQuery ajax)
     *  @param {function(string)} failure Method that is invoked if the server responds with an error (per jQuery ajax) or a non-200/300.
     */
    constructor._delete = function(url, signatureSheet, success, failure) {
        var p = {};
        p.method = &quot;DELETE&quot;;
        p.url = url;
        p.async = EcRemote.async;
        p.headers = new Object();
        p.headers[&quot;signatureSheet&quot;] = signatureSheet;
        p.success = EcRemote.getSuccessCallback(success, failure);
        p.error = EcRemote.getFailureCallback(failure);
        EcRemote.upgradeHttpToHttps(p);
        $.ajax(p);
    };
    constructor.upgradeHttpToHttps = function(p) {
        if (window != null) 
            if (window.location != null) 
                if (p.url.indexOf(window.location.protocol) == -1) 
                    if (window.location.protocol.startsWith(&quot;https&quot;)) 
                        if (!p.url.startsWith(&quot;https:&quot;)) 
                            p.url = p.url.replace(&quot;http:&quot;, &quot;https:&quot;);
    };
    constructor.handleFailure = function(failure, paramP1, paramP2, paramP3) {
        if (failure != null) 
            if (paramP1 != null) 
                if (paramP1.responseText != null) 
                    failure(paramP1.responseText);
                 else if (paramP1.statusText != null) 
                    failure(paramP1.statusText.toString());
                 else 
                    failure(&quot;General error in AJAX request.&quot;);
             else if (paramP2 != null) 
                failure(paramP2);
             else if (paramP3 != null) 
                failure(paramP2);
             else 
                failure(&quot;General error in AJAX request.&quot;);
    };
    constructor.getSuccessCallback = function(success, failure) {
        return function(arg0, arg1, arg2) {
            if (arg2.status &gt; 300 || arg2.status &lt; 200) 
                failure(&quot;Error with code: &quot; + arg2.status);
             else if (success != null) 
                success(arg2.responseText);
        };
    };
    constructor.getSuccessJSONCallback = function(success, failure) {
        return function(arg0, arg1, arg2) {
            if (arg2.status &gt; 300 || arg2.status &lt; 200) 
                failure(&quot;Error with code: &quot; + arg2.status);
             else if (success != null) 
                success(JSON.parse(arg2.responseText));
        };
    };
    constructor.getFailureCallback = function(failure) {
        return function(paramP1, paramP2, paramP3) {
            EcRemote.handleFailure(failure, paramP1, paramP2, paramP3);
        };
    };
}, {}, {});
/**
 *  A graph consisting of a set of vertices of type &lt;code&gt;V&lt;/code&gt;
 *  set and a set of edges of type &lt;code&gt;E&lt;/code&gt;.  Edges of this
 *  graph type have exactly two endpoints; whether these endpoints 
 *  must be distinct depends on the implementation.
 *  &lt;P&gt;
 *  This interface permits, but does not enforce, any of the following 
 *  common variations of graphs:
 *  &lt;ul&gt;
 *  &lt;li&gt; directed and undirected edges
 *  &lt;li&gt; vertices and edges with attributes (for example, weighted edges)
 *  &lt;li&gt; vertices and edges of different types (for example, bipartite 
 *       or multimodal graphs)
 *  &lt;li&gt; parallel edges (multiple edges which connect a single set of vertices)
 *  &lt;li&gt; representations as matrices or as adjacency lists or adjacency maps
 *  &lt;/ul&gt; 
 *  Extensions or implementations of this interface 
 *  may enforce or disallow any or all of these variations.
 *  
 *  &lt;p&gt;Definitions (with respect to a given vertex &lt;code&gt;v&lt;/code&gt;):
 *  &lt;ul&gt;
 *  &lt;li/&gt;&lt;b&gt;incoming edge&lt;/b&gt; of &lt;code&gt;v&lt;/code&gt;: an edge that can be traversed 
 *  from a neighbor of &lt;code&gt;v&lt;/code&gt; to reach &lt;code&gt;v&lt;/code&gt;
 *  &lt;li/&gt;&lt;b&gt;outgoing edge&lt;/b&gt; of &lt;code&gt;v&lt;/code&gt;: an edge that can be traversed
 *  from &lt;code&gt;v&lt;/code&gt; to reach some neighbor of &lt;code&gt;v&lt;/code&gt; 
 *  &lt;li/&gt;&lt;b&gt;predecessor&lt;/b&gt; of &lt;code&gt;v&lt;/code&gt;: a vertex at the other end of an
 *  incoming edge of &lt;code&gt;v&lt;/code&gt;
 *  &lt;li/&gt;&lt;b&gt;successor&lt;/b&gt; of &lt;code&gt;v&lt;/code&gt;: a vertex at the other end of an 
 *  outgoing edge of &lt;code&gt;v&lt;/code&gt;
 *  &lt;li/&gt;
 *  &lt;/ul&gt; 
 *  
 *  @class Graph
 *  @extends Hypergraph
 *  @author Joshua O&#x27;Madadhain
 *  
 *  Ported to Javascript by:
 *  @author Fritz Ray (Eduworks)
 *  @author Tom Buskirk (Eduworks)
 */
var Graph = function() {};
Graph = stjs.extend(Graph, null, [Hypergraph], function(constructor, prototype) {
    /**
     *  Returns a &lt;code&gt;Collection&lt;/code&gt; view of the incoming edges incident to &lt;code&gt;vertex&lt;/code&gt;
     *  in this graph.
     *  @method getInEdges
     *  @param vertex    the vertex whose incoming edges are to be returned
     *  @return  a &lt;code&gt;Collection&lt;/code&gt; view of the incoming edges incident 
     *  to &lt;code&gt;vertex&lt;/code&gt; in this graph
     */
    prototype.getInEdges = function(vertex) {};
    /**
     *  Returns a &lt;code&gt;Collection&lt;/code&gt; view of the outgoing edges incident to &lt;code&gt;vertex&lt;/code&gt;
     *  in this graph.
     *  @method getOutEdges
     *  @param vertex    the vertex whose outgoing edges are to be returned
     *  @return  a &lt;code&gt;Collection&lt;/code&gt; view of the outgoing edges incident 
     *  to &lt;code&gt;vertex&lt;/code&gt; in this graph
     */
    prototype.getOutEdges = function(vertex) {};
    /**
     *  Returns a &lt;code&gt;Collection&lt;/code&gt; view of the predecessors of &lt;code&gt;vertex&lt;/code&gt; 
     *  in this graph.  A predecessor of &lt;code&gt;vertex&lt;/code&gt; is defined as a vertex &lt;code&gt;v&lt;/code&gt; 
     *  which is connected to 
     *  &lt;code&gt;vertex&lt;/code&gt; by an edge &lt;code&gt;e&lt;/code&gt;, where &lt;code&gt;e&lt;/code&gt; is an outgoing edge of 
     *  &lt;code&gt;v&lt;/code&gt; and an incoming edge of &lt;code&gt;vertex&lt;/code&gt;.
     *  @method getPredecessors
     *  @param vertex    the vertex whose predecessors are to be returned
     *  @return  a &lt;code&gt;Collection&lt;/code&gt; view of the predecessors of 
     *  &lt;code&gt;vertex&lt;/code&gt; in this graph
     */
    prototype.getPredecessors = function(vertex) {};
    /**
     *  Returns a &lt;code&gt;Collection&lt;/code&gt; view of the successors of &lt;code&gt;vertex&lt;/code&gt; 
     *  in this graph.  A successor of &lt;code&gt;vertex&lt;/code&gt; is defined as a vertex &lt;code&gt;v&lt;/code&gt; 
     *  which is connected to 
     *  &lt;code&gt;vertex&lt;/code&gt; by an edge &lt;code&gt;e&lt;/code&gt;, where &lt;code&gt;e&lt;/code&gt; is an incoming edge of 
     *  &lt;code&gt;v&lt;/code&gt; and an outgoing edge of &lt;code&gt;vertex&lt;/code&gt;.
     *  @method getSuccessors
     *  @param vertex    the vertex whose predecessors are to be returned
     *  @return  a &lt;code&gt;Collection&lt;/code&gt; view of the successors of 
     *  &lt;code&gt;vertex&lt;/code&gt; in this graph
     */
    prototype.getSuccessors = function(vertex) {};
    /**
     *  Returns the number of incoming edges incident to &lt;code&gt;vertex&lt;/code&gt;.
     *  Equivalent to &lt;code&gt;getInEdges(vertex).size()&lt;/code&gt;.
     *  @method inDegree
     *  @param vertex    the vertex whose indegree is to be calculated
     *  @return  the number of incoming edges incident to &lt;code&gt;vertex&lt;/code&gt;
     */
    prototype.inDegree = function(vertex) {};
    /**
     *  Returns the number of outgoing edges incident to &lt;code&gt;vertex&lt;/code&gt;.
     *  Equivalent to &lt;code&gt;getOutEdges(vertex).size()&lt;/code&gt;.
     *  @method outDegree
     *  @param vertex    the vertex whose outdegree is to be calculated
     *  @return  the number of outgoing edges incident to &lt;code&gt;vertex&lt;/code&gt;
     */
    prototype.outDegree = function(vertex) {};
    /**
     *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v1&lt;/code&gt; is a predecessor of &lt;code&gt;v2&lt;/code&gt; in this graph.
     *  Equivalent to &lt;code&gt;v1.getPredecessors().contains(v2)&lt;/code&gt;.
     *  @method isPredecessor
     *  @param v1 the first vertex to be queried
     *  @param v2 the second vertex to be queried
     *  @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v1&lt;/code&gt; is a predecessor of &lt;code&gt;v2&lt;/code&gt;, and false otherwise.
     */
    prototype.isPredecessor = function(v1, v2) {};
    /**
     *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v1&lt;/code&gt; is a successor of &lt;code&gt;v2&lt;/code&gt; in this graph.
     *  Equivalent to &lt;code&gt;v1.getSuccessors().contains(v2)&lt;/code&gt;.
     *  @method isSuccessor
     *  @param v1 the first vertex to be queried
     *  @param v2 the second vertex to be queried
     *  @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v1&lt;/code&gt; is a successor of &lt;code&gt;v2&lt;/code&gt;, and false otherwise.
     */
    prototype.isSuccessor = function(v1, v2) {};
    /**
     *  Returns the number of predecessors that &lt;code&gt;vertex&lt;/code&gt; has in this graph.
     *  Equivalent to &lt;code&gt;vertex.getPredecessors().size()&lt;/code&gt;.
     *  @method getPredecessorCount
     *  @param vertex the vertex whose predecessor count is to be returned
     *  @return  the number of predecessors that &lt;code&gt;vertex&lt;/code&gt; has in this graph
     */
    prototype.getPredecessorCount = function(vertex) {};
    /**
     *  Returns the number of successors that &lt;code&gt;vertex&lt;/code&gt; has in this graph.
     *  Equivalent to &lt;code&gt;vertex.getSuccessors().size()&lt;/code&gt;.
     *  @method getSuccessorCount
     *  @param vertex the vertex whose successor count is to be returned
     *  @return  the number of successors that &lt;code&gt;vertex&lt;/code&gt; has in this graph
     */
    prototype.getSuccessorCount = function(vertex) {};
    /**
     *  If &lt;code&gt;directed_edge&lt;/code&gt; is a directed edge in this graph, returns the source; 
     *  otherwise returns &lt;code&gt;null&lt;/code&gt;. 
     *  The source of a directed edge &lt;code&gt;d&lt;/code&gt; is defined to be the vertex for which  
     *  &lt;code&gt;d&lt;/code&gt; is an outgoing edge.
     *  &lt;code&gt;directed_edge&lt;/code&gt; is guaranteed to be a directed edge if 
     *  its &lt;code&gt;EdgeType&lt;/code&gt; is &lt;code&gt;DIRECTED&lt;/code&gt;. 
     *  @method getSource
     *  @param directed_edge
     *  @return  the source of &lt;code&gt;directed_edge&lt;/code&gt; if it is a directed edge in this graph, or &lt;code&gt;null&lt;/code&gt; otherwise
     */
    prototype.getSource = function(directed_edge) {};
    /**
     *  If &lt;code&gt;directed_edge&lt;/code&gt; is a directed edge in this graph, returns the destination; 
     *  otherwise returns &lt;code&gt;null&lt;/code&gt;. 
     *  The destination of a directed edge &lt;code&gt;d&lt;/code&gt; is defined to be the vertex 
     *  incident to &lt;code&gt;d&lt;/code&gt; for which  
     *  &lt;code&gt;d&lt;/code&gt; is an incoming edge.
     *  &lt;code&gt;directed_edge&lt;/code&gt; is guaranteed to be a directed edge if 
     *  its &lt;code&gt;EdgeType&lt;/code&gt; is &lt;code&gt;DIRECTED&lt;/code&gt;. 
     *  @method getDest
     *  @param directed_edge
     *  @return  the destination of &lt;code&gt;directed_edge&lt;/code&gt; if it is a directed edge in this graph, or &lt;code&gt;null&lt;/code&gt; otherwise
     */
    prototype.getDest = function(directed_edge) {};
    /**
     *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;vertex&lt;/code&gt; is the source of &lt;code&gt;edge&lt;/code&gt;.
     *  Equivalent to &lt;code&gt;getSource(edge).equals(vertex)&lt;/code&gt;.
     *  @method isSource
     *  @param vertex the vertex to be queried
     *  @param edge the edge to be queried
     *  @return &lt;code&gt;true&lt;/code&gt; iff &lt;code&gt;vertex&lt;/code&gt; is the source of &lt;code&gt;edge&lt;/code&gt;
     */
    prototype.isSource = function(vertex, edge) {};
    /**
     *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;vertex&lt;/code&gt; is the destination of &lt;code&gt;edge&lt;/code&gt;.
     *  Equivalent to &lt;code&gt;getDest(edge).equals(vertex)&lt;/code&gt;.
     *  @param vertex the vertex to be queried
     *  @param edge the edge to be queried
     *  @return &lt;code&gt;true&lt;/code&gt; iff &lt;code&gt;vertex&lt;/code&gt; is the destination of &lt;code&gt;edge&lt;/code&gt;
     */
    prototype.isDest = function(vertex, edge) {};
    /**
     *  Adds edge &lt;code&gt;e&lt;/code&gt; to this graph such that it connects 
     *  vertex &lt;code&gt;v1&lt;/code&gt; to &lt;code&gt;v2&lt;/code&gt;.
     *  Equivalent to &lt;code&gt;addEdge(e, new Pair&lt;V&gt;(v1, v2))&lt;/code&gt;.
     *  If this graph does not contain &lt;code&gt;v1&lt;/code&gt;, &lt;code&gt;v2&lt;/code&gt;, 
     *  or both, implementations may choose to either silently add 
     *  the vertices to the graph or throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt;.
     *  If this graph assigns edge types to its edges, the edge type of
     *  &lt;code&gt;e&lt;/code&gt; will be the default for this graph.
     *  See &lt;code&gt;Hypergraph.addEdge()&lt;/code&gt; for a listing of possible reasons
     *  for failure.
     *  @method addEdge
     *  @param e the edge to be added
     *  @param v1 the first vertex to be connected
     *  @param v2 the second vertex to be connected
     *  @return &lt;code&gt;true&lt;/code&gt; if the add is successful, &lt;code&gt;false&lt;/code&gt; otherwise
     *  @see Hypergraph#addEdge(Object, Collection)
     *  @see #addEdge(Object, Object, Object, EdgeType)
     */
    prototype.addEdge = function(e, v1, v2) {};
    /**
     *  Returns the vertex at the other end of &lt;code&gt;edge&lt;/code&gt; from &lt;code&gt;vertex&lt;/code&gt;.
     *  (That is, returns the vertex incident to &lt;code&gt;edge&lt;/code&gt; which is not &lt;code&gt;vertex&lt;/code&gt;.)
     *  @method getOpposite
     *  @param vertex the vertex to be queried
     *  @param edge the edge to be queried
     *  @return the vertex at the other end of &lt;code&gt;edge&lt;/code&gt; from &lt;code&gt;vertex&lt;/code&gt;
     */
    prototype.getOpposite = function(vertex, edge) {};
}, {}, {});
/**
 *  A directed implementation of {{#crossLink &quot;Graph&quot;}}Graph{{/crossLink}}. Edges have types. Two vertices may have many edges between them.
 *  @class EcDirectedGraph
 *  @extends Graph
 *  @author fray
 * 
 *  @param &lt;V&gt;
 *  @param &lt;E&gt;
 */
var EcDirectedGraph = function() {};
EcDirectedGraph = stjs.extend(EcDirectedGraph, null, [Graph], function(constructor, prototype) {
    prototype.edges = null;
    prototype.verticies = null;
    prototype.getEdges = function() {
        var results = new Array();
        for (var i = 0; i &lt; this.edges.length; i++) 
            results[i] = this.edges[i].edge;
        return results;
    };
    prototype.getVertices = function() {
        var results = new Array();
        for (var i = 0; i &lt; this.verticies.length; i++) 
            results[i] = this.verticies[i];
        return results;
    };
    prototype.containsVertex = function(vertex) {
        for (var i = 0; i &lt; this.verticies.length; i++) 
            if (vertex.equals(this.verticies[i])) 
                return true;
        return false;
    };
    prototype.containsEdge = function(edge) {
        for (var i = 0; i &lt; this.edges.length; i++) 
            if (edge.equals(this.edges[i].edge)) 
                return true;
        return false;
    };
    prototype.getEdgeCount = function() {
        return this.edges.length;
    };
    prototype.getVertexCount = function() {
        return this.verticies.length;
    };
    prototype.getNeighbors = function(vertex) {
        var results = new Array();
        for (var i = 0; i &lt; this.edges.length; i++) {
            if (vertex.equals(this.edges[i].source)) 
                results.push(this.edges[i].destination);
             else if (vertex.equals(this.edges[i].destination)) 
                results.push(this.edges[i].source);
        }
        EcArray.removeDuplicates(results);
        return results;
    };
    prototype.getIncidentEdges = function(vertex) {
        var results = new Array();
        for (var i = 0; i &lt; this.edges.length; i++) {
            if (vertex.equals(this.edges[i].source)) 
                results.push(this.edges[i].edge);
             else if (vertex.equals(this.edges[i].destination)) 
                results.push(this.edges[i].edge);
        }
        EcArray.removeDuplicates(results);
        return results;
    };
    prototype.getIncidentVertices = function(edge) {
        var results = new Array();
        for (var i = 0; i &lt; this.edges.length; i++) {
            if (edge.equals(this.edges[i].edge)) {
                results.push(this.edges[i].source);
                results.push(this.edges[i].destination);
            }
        }
        EcArray.removeDuplicates(results);
        return results;
    };
    prototype.findEdge = function(v1, v2) {
        for (var i = 0; i &lt; this.edges.length; i++) {
            if (v1.equals(this.edges[i].source) &amp;&amp; v2.equals(this.edges[i].destination)) 
                return this.edges[i].edge;
            if (v1.equals(this.edges[i].destination) &amp;&amp; v2.equals(this.edges[i].source)) 
                return this.edges[i].edge;
        }
        return null;
    };
    prototype.findEdgeSet = function(v1, v2) {
        var results = new Array();
        for (var i = 0; i &lt; this.edges.length; i++) {
            if (v1.equals(this.edges[i].source) &amp;&amp; v2.equals(this.edges[i].destination)) 
                results.push(this.edges[i].edge);
            if (v1.equals(this.edges[i].destination) &amp;&amp; v2.equals(this.edges[i].source)) 
                results.push(this.edges[i].edge);
        }
        return results;
    };
    prototype.addVertex = function(vertex) {
        if (this.verticies.indexOf(vertex) != -1) 
            return false;
        this.verticies.push(vertex);
        return true;
    };
    prototype.removeVertex = function(vertex) {
        var indexOf = this.verticies.indexOf(vertex);
        if (indexOf != -1) {
            for (var i = 0; i &lt; this.edges.length; i++) {
                if (this.edges[i].source.equals(vertex) || this.edges[i].destination.equals(vertex)) {
                    this.edges.splice(i, 1);
                    i--;
                }
            }
            this.verticies.splice(indexOf, 1);
            return true;
        }
        return false;
    };
    prototype.removeEdge = function(edge) {
        var success = false;
        for (var i = 0; i &lt; this.edges.length; i++) {
            if (this.edges[i].edge.equals(edge)) {
                this.edges.splice(i, 1);
                i--;
                success = true;
            }
        }
        return success;
    };
    prototype.isNeighbor = function(v1, v2) {
        for (var i = 0; i &lt; this.edges.length; i++) {
            if (v1.equals(this.edges[i].source) &amp;&amp; v2.equals(this.edges[i].destination)) 
                return true;
             else if (v1.equals(this.edges[i].destination) &amp;&amp; v2.equals(this.edges[i].source)) 
                return true;
        }
        return false;
    };
    prototype.isIncident = function(vertex, edge) {
        for (var i = 0; i &lt; this.edges.length; i++) {
            if ((vertex.equals(this.edges[i].source) || vertex.equals(this.edges[i].destination)) &amp;&amp; edge.equals(this.edges[i].edge)) 
                return true;
        }
        return false;
    };
    prototype.degree = function(vertex) {
        var count = 0;
        for (var i = 0; i &lt; this.edges.length; i++) {
            if (vertex.equals(this.edges[i].source) || vertex.equals(this.edges[i].destination)) 
                count++;
        }
        return count;
    };
    prototype.getNeighborCount = function(vertex) {
        return this.getNeighbors(vertex).length;
    };
    prototype.getIncidentCount = function(edge) {
        return this.getIncidentVertices(edge).length;
    };
    prototype.getEdgeType = function(edge) {};
    prototype.getDefaultEdgeType = function() {};
    prototype.getEdgesOfType = function(edge_type) {
        var results = new Array();
        for (var i = 0; i &lt; this.edges.length; i++) {
            if (this.getEdgeType(this.edges[i].edge) == edge_type) 
                results.push(this.edges[i].edge);
        }
        return results;
    };
    prototype.getEdgeCountOfType = function(edge_type) {
        return this.getEdgesOfType(edge_type).length;
    };
    prototype.getInEdges = function(vertex) {
        var results = new Array();
        for (var i = 0; i &lt; this.edges.length; i++) {
            if (vertex.equals(this.edges[i].destination)) 
                results.push(this.edges[i].edge);
        }
        EcArray.removeDuplicates(results);
        return results;
    };
    prototype.getOutEdges = function(vertex) {
        var results = new Array();
        for (var i = 0; i &lt; this.edges.length; i++) {
            if (vertex.equals(this.edges[i].source)) 
                results.push(this.edges[i].edge);
        }
        EcArray.removeDuplicates(results);
        return results;
    };
    prototype.inDegree = function(vertex) {
        return this.getInEdges(vertex).length;
    };
    prototype.outDegree = function(vertex) {
        return this.getOutEdges(vertex).length;
    };
    prototype.getSource = function(directed_edge) {
        for (var i = 0; i &lt; this.edges.length; i++) {
            if (directed_edge.equals(this.edges[i].edge)) 
                return this.edges[i].source;
        }
        return null;
    };
    prototype.getDest = function(directed_edge) {
        for (var i = 0; i &lt; this.edges.length; i++) {
            if (directed_edge.equals(this.edges[i].edge)) 
                return this.edges[i].destination;
        }
        return null;
    };
    prototype.getPredecessors = function(vertex) {
        var results = new Array();
        for (var i = 0; i &lt; this.edges.length; i++) {
            if (vertex.equals(this.edges[i].destination)) 
                results.push(this.edges[i].source);
        }
        EcArray.removeDuplicates(results);
        return results;
    };
    prototype.getSuccessors = function(vertex) {
        var results = new Array();
        for (var i = 0; i &lt; this.edges.length; i++) {
            if (vertex.equals(this.edges[i].source)) 
                results.push(this.edges[i].destination);
        }
        EcArray.removeDuplicates(results);
        return results;
    };
    prototype.isPredecessor = function(v1, v2) {
        for (var i = 0; i &lt; this.edges.length; i++) {
            if (v1.equals(this.edges[i].destination)) 
                if (v2.equals(this.edges[i].source)) 
                    return true;
        }
        return false;
    };
    prototype.isSuccessor = function(v1, v2) {
        for (var i = 0; i &lt; this.edges.length; i++) {
            if (v2.equals(this.edges[i].destination)) 
                if (v1.equals(this.edges[i].source)) 
                    return true;
        }
        return false;
    };
    prototype.getPredecessorCount = function(vertex) {
        return this.getPredecessors(vertex).length;
    };
    prototype.getSuccessorCount = function(vertex) {
        return this.getSuccessors(vertex).length;
    };
    prototype.isSource = function(vertex, edge) {
        for (var i = 0; i &lt; this.edges.length; i++) {
            if (edge.equals(this.edges[i].edge)) 
                if (vertex.equals(this.edges[i].source)) 
                    return true;
        }
        return false;
    };
    prototype.isDest = function(vertex, edge) {
        for (var i = 0; i &lt; this.edges.length; i++) {
            if (edge.equals(this.edges[i].edge)) 
                if (vertex.equals(this.edges[i].destination)) 
                    return true;
        }
        return false;
    };
    prototype.addEdge = function(e, v1, v2) {
        this.addVertex(v1);
        this.addVertex(v2);
        var t = new Triple();
        t.source = v1;
        t.destination = v2;
        t.edge = e;
        if (this.edges.indexOf(t) != -1) 
            return false;
        this.edges.push(t);
        return true;
    };
    prototype.getOpposite = function(vertex, edge) {
        for (var i = 0; i &lt; this.edges.length; i++) {
            if (edge.equals(this.edges[i].edge)) 
                if (vertex.equals(this.edges[i].destination)) 
                    return this.edges[i].source;
                 else if (vertex.equals(this.edges[i].source)) 
                    return this.edges[i].destination;
        }
        return null;
    };
}, {edges: {name: &quot;Array&quot;, arguments: [{name: &quot;Triple&quot;, arguments: [&quot;V&quot;, &quot;V&quot;, &quot;E&quot;]}]}, verticies: {name: &quot;Array&quot;, arguments: [&quot;V&quot;]}}, {});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
