<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>cass.rollup.js - CASS Javascript Library</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="http://www.cassproject.org/_/rsrc/1451948061999/config/customLogo.gif?revision=16" title="CASS Javascript Library"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Action.html">Action</a></li>
                                <li><a href="../classes/AlignmentObject.html">AlignmentObject</a></li>
                                <li><a href="../classes/CreativeWork.html">CreativeWork</a></li>
                                <li><a href="../classes/Ebac.html">Ebac</a></li>
                                <li><a href="../classes/EcAes.html">EcAes</a></li>
                                <li><a href="../classes/EcAesCtr.html">EcAesCtr</a></li>
                                <li><a href="../classes/EcAesCtrAsync.html">EcAesCtrAsync</a></li>
                                <li><a href="../classes/EcArray.html">EcArray</a></li>
                                <li><a href="../classes/EcAsyncHelper.html">EcAsyncHelper</a></li>
                                <li><a href="../classes/EcDirectedGraph.html">EcDirectedGraph</a></li>
                                <li><a href="../classes/EcLinkedData.html">EcLinkedData</a></li>
                                <li><a href="../classes/EcObject.html">EcObject</a></li>
                                <li><a href="../classes/EcPk.html">EcPk</a></li>
                                <li><a href="../classes/EcPpk.html">EcPpk</a></li>
                                <li><a href="../classes/EcRemote.html">EcRemote</a></li>
                                <li><a href="../classes/EcRemoteLinkedData.html">EcRemoteLinkedData</a></li>
                                <li><a href="../classes/EcRsaOaep.html">EcRsaOaep</a></li>
                                <li><a href="../classes/EcRsaOaepAsync.html">EcRsaOaepAsync</a></li>
                                <li><a href="../classes/General.html">General</a></li>
                                <li><a href="../classes/Graph.html">Graph</a></li>
                                <li><a href="../classes/Hypergraph.html">Hypergraph</a></li>
                                <li><a href="../classes/Person.html">Person</a></li>
                                <li><a href="../classes/Triple.html">Triple</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: cass.rollup.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
 Copyright 2015-2016 Eduworks Corporation and other contributing parties.

 Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
*/
var InquiryPacket = function(subject, competency, level, context, success, failure, rule, type) {
    this.positive = new Array();
    this.negative = new Array();
    this.equivalentPackets = new Array();
    this.subPackets = new Array();
    this.dateCreated = new Date().getTime();
    this.subject = subject;
    this.competency = new Array();
    if (competency != null) 
        this.competency.push(competency);
    this.level = level;
    this.context = context;
    this.success = success;
    this.failure = failure;
    this.rule = rule;
    this.type = type;
    this.result = null;
    this.log = &quot;&quot;;
};
InquiryPacket = stjs.extend(InquiryPacket, null, [], function(constructor, prototype) {
    constructor.IPType = stjs.enumeration(&quot;COMPETENCY&quot;, &quot;ROLLUPRULE&quot;, &quot;RELATION_AND&quot;, &quot;RELATION_OR&quot;, &quot;RELATION_NARROWS&quot;, &quot;RELATION_BROADENS&quot;, &quot;RELATION_REQUIRES&quot;, &quot;RELATION_ISREQUIREDBY&quot;);
    constructor.ResultType = stjs.enumeration(&quot;TRUE&quot;, &quot;FALSE&quot;, &quot;UNKNOWN&quot;, &quot;INDETERMINANT&quot;);
    prototype.subject = null;
    prototype.competency = null;
    prototype.context = null;
    prototype.success = null;
    prototype.ask = null;
    prototype.failure = null;
    prototype.level = null;
    prototype.equivalentPackets = null;
    prototype.subPackets = null;
    prototype.dateCreated = 0.0;
    prototype.hasCheckedAssertionsForCompetency = false;
    prototype.hasCheckedRollupRulesForCompetency = false;
    prototype.hasCheckedRelationshipsForCompetency = false;
    prototype.numberOfQueriesRunning = 0;
    prototype.log = null;
    prototype.positive = null;
    prototype.negative = null;
    prototype.status = null;
    prototype.finished = false;
    prototype.type = null;
    prototype.rule = null;
    prototype.result = null;
    prototype.getContext = function() {
        return this.context;
    };
    prototype.anyIndeterminantChildPackets = function() {
        for (var i = 0; i &lt; this.equivalentPackets.length; i++) {
            if (InquiryPacket.ResultType.INDETERMINANT.equals(this.equivalentPackets[i].result)) 
                return true;
        }
        for (var i = 0; i &lt; this.subPackets.length; i++) {
            if (InquiryPacket.ResultType.INDETERMINANT.equals(this.subPackets[i].result)) 
                return true;
        }
        return false;
    };
    prototype.allChildPacketsUnknown = function() {
        for (var i = 0; i &lt; this.equivalentPackets.length; i++) {
            if (!InquiryPacket.ResultType.UNKNOWN.equals(this.equivalentPackets[i].result)) 
                return false;
        }
        for (var i = 0; i &lt; this.subPackets.length; i++) {
            if (!InquiryPacket.ResultType.UNKNOWN.equals(this.subPackets[i].result)) 
                return false;
        }
        return true;
    };
    prototype.anyChildPacketsAreFalse = function() {
        for (var i = 0; i &lt; this.equivalentPackets.length; i++) {
            if (InquiryPacket.ResultType.FALSE.equals(this.equivalentPackets[i].result)) 
                return true;
        }
        for (var i = 0; i &lt; this.subPackets.length; i++) {
            if (InquiryPacket.ResultType.FALSE.equals(this.subPackets[i].result)) 
                return true;
        }
        return false;
    };
    prototype.anyChildPacketsAreUnknown = function() {
        for (var i = 0; i &lt; this.equivalentPackets.length; i++) {
            if (InquiryPacket.ResultType.UNKNOWN.equals(this.equivalentPackets[i].result)) 
                return true;
        }
        for (var i = 0; i &lt; this.subPackets.length; i++) {
            if (InquiryPacket.ResultType.UNKNOWN.equals(this.subPackets[i].result)) 
                return true;
        }
        return false;
    };
    prototype.anyChildPacketsAreTrue = function() {
        for (var i = 0; i &lt; this.equivalentPackets.length; i++) {
            if (InquiryPacket.ResultType.TRUE.equals(this.equivalentPackets[i].result)) 
                return true;
        }
        for (var i = 0; i &lt; this.subPackets.length; i++) {
            if (InquiryPacket.ResultType.TRUE.equals(this.subPackets[i].result)) 
                return true;
        }
        return false;
    };
    prototype.allEquivalentPacketsUnknown = function() {
        for (var i = 0; i &lt; this.equivalentPackets.length; i++) {
            if (!InquiryPacket.ResultType.UNKNOWN.equals(this.equivalentPackets[i].result)) 
                return false;
        }
        return true;
    };
    prototype.allEquivalentPacketsTrueOrUnknown = function() {
        for (var i = 0; i &lt; this.equivalentPackets.length; i++) {
            if (InquiryPacket.ResultType.FALSE.equals(this.equivalentPackets[i].result) || InquiryPacket.ResultType.INDETERMINANT.equals(this.equivalentPackets[i].result)) 
                return false;
        }
        return true;
    };
    prototype.allSubPacketsTrueOrUnknown = function() {
        for (var i = 0; i &lt; this.subPackets.length; i++) {
            if (InquiryPacket.ResultType.FALSE.equals(this.subPackets[i].result) || InquiryPacket.ResultType.INDETERMINANT.equals(this.subPackets[i].result)) 
                return false;
        }
        return true;
    };
    prototype.allEquivalentPacketsFalseOrUnknown = function() {
        for (var i = 0; i &lt; this.equivalentPackets.length; i++) {
            if (InquiryPacket.ResultType.TRUE.equals(this.equivalentPackets[i].result) || InquiryPacket.ResultType.INDETERMINANT.equals(this.equivalentPackets[i].result)) 
                return false;
        }
        return true;
    };
    prototype.allSubPacketsFalseOrUnknown = function() {
        for (var i = 0; i &lt; this.subPackets.length; i++) {
            if (InquiryPacket.ResultType.TRUE.equals(this.subPackets[i].result) || InquiryPacket.ResultType.INDETERMINANT.equals(this.subPackets[i].result)) 
                return false;
        }
        return true;
    };
    prototype.hasId = function(competencyId) {
        for (var i = 0; i &lt; this.competency.length; i++) 
            if (this.competency[i].isId(competencyId)) 
                return true;
        return false;
    };
}, {subject: {name: &quot;Array&quot;, arguments: [&quot;EcPk&quot;]}, competency: {name: &quot;Array&quot;, arguments: [&quot;EcCompetency&quot;]}, context: &quot;EcFramework&quot;, success: {name: &quot;Callback1&quot;, arguments: [&quot;InquiryPacket&quot;]}, ask: {name: &quot;Function1&quot;, arguments: [null, null]}, failure: {name: &quot;Callback1&quot;, arguments: [null]}, level: &quot;EcLevel&quot;, equivalentPackets: {name: &quot;Array&quot;, arguments: [&quot;InquiryPacket&quot;]}, subPackets: {name: &quot;Array&quot;, arguments: [&quot;InquiryPacket&quot;]}, positive: {name: &quot;Array&quot;, arguments: [&quot;EcAssertion&quot;]}, negative: {name: &quot;Array&quot;, arguments: [&quot;EcAssertion&quot;]}, type: {name: &quot;Enum&quot;, arguments: [&quot;InquiryPacket.IPType&quot;]}, result: {name: &quot;Enum&quot;, arguments: [&quot;InquiryPacket.ResultType&quot;]}}, {});
var RrToken = function() {};
RrToken = stjs.extend(RrToken, null, [], function(constructor, prototype) {
    prototype.number = null;
    prototype.bool = null;
}, {}, {});
var RrQuery = function() {};
RrQuery = stjs.extend(RrQuery, null, [], function(constructor, prototype) {
    prototype.query = null;
}, {}, {});
var RrS = function() {
    this.token = new Array();
    this.query = new Array();
};
RrS = stjs.extend(RrS, null, [], function(constructor, prototype) {
    prototype.token = null;
    prototype.query = null;
    prototype.addToken = function(rrToken) {
        this.token.push(rrToken);
    };
    prototype.addQuery = function(rrQuery) {
        this.query.push(rrQuery);
    };
}, {token: {name: &quot;Array&quot;, arguments: [&quot;RrToken&quot;]}, query: {name: &quot;Array&quot;, arguments: [&quot;RrQuery&quot;]}}, {});
var RollupRuleInterface = function(input, processor) {
    var chars = new antlr4.InputStream(input);
    var lexer = new RollupLexer.RollupLexer(chars);
    var tokens = new antlr4.CommonTokenStream(lexer);
    this.parser = new RollupParser.RollupParser(tokens);
    this.parser.buildParseTrees = true;
    this.listener = new RollupListener.RollupListener();
    this.processor = processor;
    var me = this;
    this.listener.enterS = function(ctx) {
        me.processor.enterS(ctx);
    };
    this.listener.exitS = function(ctx) {
        me.processor.exitS(ctx);
        me.success(true);
    };
    this.listener.exitToken = function(ctx) {
        me.processor.exitToken(ctx);
    };
    this.listener.enterQuery = function(ctx) {
        me.processor.enterQuery(ctx);
    };
    this.listener.exitQuery = function(ctx) {
        me.processor.exitQuery(ctx);
    };
    this.listener.exitInnerquery = function(ctx) {
        me.processor.exitInnerquery(ctx);
    };
    this.listener.exitLogical_or_math_operator = function(ctx) {
        me.processor.exitLogical_or_math_operator(ctx);
    };
    this.parser.addParseListener(this.listener);
};
RollupRuleInterface = stjs.extend(RollupRuleInterface, null, [], function(constructor, prototype) {
    prototype.listener = null;
    prototype.logFunction = null;
    prototype.parser = null;
    prototype.processor = null;
    prototype.success = null;
    prototype.failure = null;
    prototype.go = function() {
        this.processor.logFunction = this.logFunction;
        this.processor.success = this.success;
        this.processor.failure = this.failure;
        this.parser.s();
    };
}, {listener: &quot;RollupListener.RollupListener&quot;, logFunction: {name: &quot;Callback1&quot;, arguments: [&quot;Object&quot;]}, parser: &quot;RollupParser.RollupParser&quot;, processor: &quot;RollupRuleProcessor&quot;, success: {name: &quot;Callback1&quot;, arguments: [null]}, failure: {name: &quot;Callback1&quot;, arguments: [null]}}, {});
var RollupRulePacketGenerator = function(ip, ep) {
    this.ip = ip;
    this.ep = ep;
    this.queries = new Array();
    this.queryOperations = new Array();
};
RollupRulePacketGenerator = stjs.extend(RollupRulePacketGenerator, null, [], function(constructor, prototype) {
    constructor.OperationType = stjs.enumeration(&quot;AND&quot;, &quot;OR&quot;);
    prototype.queries = null;
    prototype.queryOperations = null;
    prototype.ip = null;
    prototype.ep = null;
    prototype.addQuery = function(query) {
        this.queries.push(query);
    };
    prototype.addQueryOperation = function(operation) {
        this.queryOperations.push(operation);
    };
    prototype.hasOrOperation = function() {
        for (var i = 0; i &lt; this.queryOperations.length; i++) {
            if (RollupRulePacketGenerator.OperationType.OR.equals(this.queryOperations[i])) 
                return true;
        }
        return false;
    };
    prototype.getIPType = function() {
        if (this.hasOrOperation()) 
            return InquiryPacket.IPType.RELATION_OR;
        return InquiryPacket.IPType.RELATION_AND;
    };
    prototype.generateComboAndPacket = function() {
        var meEp = this.ep;
        var meIp = this.ip;
        return new InquiryPacket(this.ip.subject, null, null, this.ip.context, function(p1) {
            if (meEp != null) 
                meEp.continueProcessing(meIp);
        }, this.ip.failure, null, InquiryPacket.IPType.RELATION_AND);
    };
    prototype.generateRollupRulePacket = function(rule) {
        var meEp = this.ep;
        var meIp = this.ip;
        return new InquiryPacket(this.ip.subject, null, null, this.ip.context, function(p1) {
            if (meEp != null) 
                meEp.continueProcessing(meIp);
        }, this.ip.failure, rule, InquiryPacket.IPType.ROLLUPRULE);
    };
    prototype.addAllQueries = function(rollupIp) {
        for (var i = 0; i &lt; this.queries.length; i++) {
            rollupIp.subPackets.push(this.generateRollupRulePacket(this.queries[i]));
        }
    };
    prototype.buildQueryTree = function(rollupIp) {
        if (this.queryOperations.length &lt;= 0) 
            return;
        var currentAndPacket = this.generateComboAndPacket();
        var priorOt;
        if (RollupRulePacketGenerator.OperationType.OR.equals(this.queryOperations[0])) 
            rollupIp.subPackets.push(this.generateRollupRulePacket(this.queries[0]));
         else 
            currentAndPacket.subPackets.push(this.generateRollupRulePacket(this.queries[0]));
        priorOt = this.queryOperations[0];
        for (var i = 1; i &lt; this.queryOperations.length; i++) {
            if (RollupRulePacketGenerator.OperationType.OR.equals(this.queryOperations[i])) {
                if (RollupRulePacketGenerator.OperationType.OR.equals(priorOt)) 
                    rollupIp.subPackets.push(this.generateRollupRulePacket(this.queries[i]));
                 else {
                    currentAndPacket.subPackets.push(this.generateRollupRulePacket(this.queries[i]));
                    rollupIp.subPackets.push(currentAndPacket);
                }
            } else {
                if (RollupRulePacketGenerator.OperationType.OR.equals(priorOt)) {
                    currentAndPacket = this.generateComboAndPacket();
                    currentAndPacket.subPackets.push(this.generateRollupRulePacket(this.queries[i]));
                } else 
                    currentAndPacket.subPackets.push(this.generateRollupRulePacket(this.queries[i]));
            }
            priorOt = this.queryOperations[i];
        }
        if (RollupRulePacketGenerator.OperationType.OR.equals(priorOt)) 
            rollupIp.subPackets.push(this.generateRollupRulePacket(this.queries[this.queries.length - 1]));
         else {
            currentAndPacket.subPackets.push(this.generateRollupRulePacket(this.queries[this.queries.length - 1]));
            rollupIp.subPackets.push(currentAndPacket);
        }
    };
    prototype.generatePacket = function() {
        var ipt = this.getIPType();
        var meEp = this.ep;
        var meIp = this.ip;
        var rollupIp = new InquiryPacket(this.ip.subject, null, null, this.ip.context, function(p1) {
            if (meEp != null) 
                meEp.continueProcessing(meIp);
        }, this.ip.failure, null, ipt);
        if (InquiryPacket.IPType.RELATION_AND.equals(ipt)) 
            this.addAllQueries(rollupIp);
         else 
            this.buildQueryTree(rollupIp);
        return rollupIp;
    };
    constructor.main = function(args) {};
}, {queries: {name: &quot;Array&quot;, arguments: [null]}, queryOperations: {name: &quot;Array&quot;, arguments: [{name: &quot;Enum&quot;, arguments: [&quot;RollupRulePacketGenerator.OperationType&quot;]}]}, ip: &quot;InquiryPacket&quot;, ep: &quot;AssertionProcessor&quot;}, {});
if (!stjs.mainCallDisabled) 
    RollupRulePacketGenerator.main();
var RelationshipPacketGenerator = function(ip, ep, processedAlignments) {
    this.ip = ip;
    this.ep = ep;
    this.processedAlignments = processedAlignments;
    this.narrowsPackets = new Array();
    this.broadensPackets = new Array();
    this.requiredPackets = new Array();
    this.isRequiredByPackets = new Array();
};
RelationshipPacketGenerator = stjs.extend(RelationshipPacketGenerator, null, [], function(constructor, prototype) {
    prototype.failure = null;
    prototype.success = null;
    prototype.logFunction = null;
    prototype.numberOfRelationsToProcess = 0;
    prototype.numberOfRelationsProcessed = 0;
    prototype.narrowsPackets = null;
    prototype.broadensPackets = null;
    prototype.requiredPackets = null;
    prototype.isRequiredByPackets = null;
    prototype.processedAlignments = null;
    prototype.ep = null;
    prototype.ip = null;
    prototype.log = function(string) {
        if (this.logFunction != null) 
            this.logFunction(string);
    };
    prototype.processEventFailure = function(message, ip) {
        ip.numberOfQueriesRunning--;
        this.failure(message);
    };
    prototype.pushRequiredPacketsToIp = function() {
        if (this.requiredPackets.length &gt; 0) {
            var meEp = this.ep;
            var meIp = this.ip;
            var rootRequiredPacket = new InquiryPacket(this.ip.subject, null, null, this.ip.context, function(p1) {
                if (meEp != null) 
                    meEp.continueProcessing(meIp);
            }, this.ip.failure, null, InquiryPacket.IPType.RELATION_REQUIRES);
            rootRequiredPacket.subPackets = this.requiredPackets;
            this.ip.subPackets.push(rootRequiredPacket);
        }
    };
    prototype.pushIsRequiredByPacketsToIp = function() {
        if (this.isRequiredByPackets.length &gt; 0) {
            var meEp = this.ep;
            var meIp = this.ip;
            var rootRequiredPacket = new InquiryPacket(this.ip.subject, null, null, this.ip.context, function(p1) {
                if (meEp != null) 
                    meEp.continueProcessing(meIp);
            }, this.ip.failure, null, InquiryPacket.IPType.RELATION_ISREQUIREDBY);
            rootRequiredPacket.subPackets = this.requiredPackets;
            this.ip.subPackets.push(rootRequiredPacket);
        }
    };
    prototype.pushNarrowsPacketsToIp = function() {
        if (this.narrowsPackets.length &gt; 0) {
            var meEp = this.ep;
            var meIp = this.ip;
            var rootNarrowsPacket = new InquiryPacket(this.ip.subject, null, null, this.ip.context, function(p1) {
                if (meEp != null) 
                    meEp.continueProcessing(meIp);
            }, this.ip.failure, null, InquiryPacket.IPType.RELATION_NARROWS);
            rootNarrowsPacket.subPackets = this.narrowsPackets;
            this.ip.subPackets.push(rootNarrowsPacket);
        }
    };
    prototype.pushBroadensPacketsToIp = function() {
        if (this.broadensPackets.length &gt; 0) {
            var meEp = this.ep;
            var meIp = this.ip;
            var rootBroadensPacket = new InquiryPacket(this.ip.subject, null, null, this.ip.context, function(p1) {
                if (meEp != null) 
                    meEp.continueProcessing(meIp);
            }, this.ip.failure, null, InquiryPacket.IPType.RELATION_BROADENS);
            rootBroadensPacket.subPackets = this.broadensPackets;
            this.ip.subPackets.push(rootBroadensPacket);
        }
    };
    prototype.finishRelationProcessing = function() {
        this.pushRequiredPacketsToIp();
        this.pushNarrowsPacketsToIp();
        this.pushBroadensPacketsToIp();
        this.success();
    };
    prototype.processGetRelatedCompetencySuccess = function(relatedCompetency, alignment) {
        this.numberOfRelationsProcessed++;
        var meEp = this.ep;
        var meIp = this.ip;
        if (this.processedAlignments[alignment.shortId()] != null) {
            this.ip.numberOfQueriesRunning--;
            this.checkForFinish();
            return;
        }
        this.processedAlignments[alignment.shortId()] = &quot;done&quot;;
        this.log(&quot;Adding new &quot; + alignment.relationType + &quot; relationship packet&quot;);
        if (EcAlignment.IS_EQUIVALENT_TO.equals(alignment.relationType)) {
            var ip2 = null;
            this.ip.equivalentPackets.push(ip2 = new InquiryPacket(this.ip.subject, relatedCompetency, null, this.ip.context, function(p1) {
                if (meEp != null) 
                    meEp.continueProcessing(meIp);
            }, this.ip.failure, null, InquiryPacket.IPType.COMPETENCY));
        } else if (EcAlignment.REQUIRES.equals(alignment.relationType)) {
            if (this.ip.hasId(alignment.source)) 
                this.requiredPackets.push(new InquiryPacket(this.ip.subject, relatedCompetency, null, this.ip.context, function(p1) {
                    if (meEp != null) 
                        meEp.continueProcessing(meIp);
                }, this.ip.failure, null, InquiryPacket.IPType.COMPETENCY));
             else 
                this.isRequiredByPackets.push(new InquiryPacket(this.ip.subject, relatedCompetency, null, this.ip.context, function(p1) {
                    if (meEp != null) 
                        meEp.continueProcessing(meIp);
                }, this.ip.failure, null, InquiryPacket.IPType.COMPETENCY));
        } else if (EcAlignment.NARROWS.equals(alignment.relationType)) {
            if (this.ip.hasId(alignment.source)) 
                this.narrowsPackets.push(new InquiryPacket(this.ip.subject, relatedCompetency, null, this.ip.context, function(p1) {
                    if (meEp != null) 
                        meEp.continueProcessing(meIp);
                }, this.ip.failure, null, InquiryPacket.IPType.COMPETENCY));
             else 
                this.broadensPackets.push(new InquiryPacket(this.ip.subject, relatedCompetency, null, this.ip.context, function(p1) {
                    if (meEp != null) 
                        meEp.continueProcessing(meIp);
                }, this.ip.failure, null, InquiryPacket.IPType.COMPETENCY));
        }
        this.ip.numberOfQueriesRunning--;
        this.checkForFinish();
    };
    prototype.checkForFinish = function() {
        if (this.numberOfRelationsProcessed &gt;= this.numberOfRelationsToProcess) 
            this.finishRelationProcessing();
    };
    prototype.processFindCompetencyRelationshipSuccess = function(alignment, ip) {
        ip.numberOfQueriesRunning--;
        var relatedCompetencyId = null;
        if (ip.hasId(alignment.source)) 
            relatedCompetencyId = alignment.target;
         else if (ip.hasId(alignment.target)) 
            relatedCompetencyId = alignment.source;
         else {
            this.numberOfRelationsProcessed++;
            this.checkForFinish();
            return;
        }
        this.log(&quot;Relationship found (&quot; + alignment.relationType + &quot;) source: &quot; + alignment.source + &quot; target: &quot; + alignment.target);
        ip.numberOfQueriesRunning++;
        var rpg = this;
        EcCompetency.get(relatedCompetencyId, function(p1) {
            rpg.processGetRelatedCompetencySuccess(p1, alignment);
        }, function(p1) {
            rpg.processEventFailure(p1, ip);
        });
    };
    prototype.go = function() {
        var rpg = this;
        if (this.ip.getContext().relation == null) 
            this.success();
         else {
            this.numberOfRelationsToProcess = this.ip.getContext().relation.length;
            this.numberOfRelationsProcessed = 0;
            for (var i = 0; i &lt; this.ip.getContext().relation.length; i++) {
                this.ip.numberOfQueriesRunning++;
                EcAlignment.get(this.ip.getContext().relation[i], function(p1) {
                    rpg.processFindCompetencyRelationshipSuccess(p1, rpg.ip);
                }, function(p1) {
                    rpg.processEventFailure(p1, rpg.ip);
                });
            }
        }
    };
}, {failure: {name: &quot;Callback1&quot;, arguments: [null]}, success: &quot;Callback0&quot;, logFunction: {name: &quot;Callback1&quot;, arguments: [&quot;Object&quot;]}, narrowsPackets: {name: &quot;Array&quot;, arguments: [&quot;InquiryPacket&quot;]}, broadensPackets: {name: &quot;Array&quot;, arguments: [&quot;InquiryPacket&quot;]}, requiredPackets: {name: &quot;Array&quot;, arguments: [&quot;InquiryPacket&quot;]}, isRequiredByPackets: {name: &quot;Array&quot;, arguments: [&quot;InquiryPacket&quot;]}, processedAlignments: {name: &quot;Map&quot;, arguments: [null, null]}, ep: &quot;AssertionProcessor&quot;, ip: &quot;InquiryPacket&quot;}, {});
var RollupRuleGenerator = function(ip) {
    this.ip = ip;
    this.rule = &quot;&quot;;
    this.outerRule = &quot;&quot;;
};
RollupRuleGenerator = stjs.extend(RollupRuleGenerator, null, [], function(constructor, prototype) {
    prototype.failure = null;
    prototype.success = null;
    prototype.rule = null;
    prototype.outerRule = null;
    prototype.ip = null;
    prototype.go = function() {
        var me = this;
        if (this.ip.getContext().relation == null) 
            this.success(null);
         else 
            for (var i = 0; i &lt; this.ip.getContext().relation.length; i++) {
                this.ip.numberOfQueriesRunning++;
                EcAlignment.get(this.ip.getContext().relation[i], function(p1) {
                    me.ip.numberOfQueriesRunning--;
                    if (!p1.source.equals(me.ip.competency) &amp;&amp; !p1.target.equals(me.ip.competency)) 
                        return;
                    if (p1.source.equals(me.ip.competency)) {
                        if (p1.relationType.equals(EcAlignment.REQUIRES)) {
                            if (me.rule != null &amp;&amp; me.rule != &quot;&quot;) 
                                me.rule += &quot; AND &quot;;
                            me.rule += &quot;[notNegative competency:\&quot;&quot; + p1.target + &quot;\&quot;]&quot;;
                        }
                        if (p1.relationType.equals(EcAlignment.NARROWS)) {
                            if (me.outerRule != null &amp;&amp; me.outerRule != &quot;&quot;) 
                                me.outerRule += &quot; OR &quot;;
                            me.outerRule += &quot;[competency:\&quot;&quot; + p1.target + &quot;\&quot;]&quot;;
                        }
                    }
                }, function(p1) {
                    me.ip.numberOfQueriesRunning--;
                });
            }
    };
}, {failure: {name: &quot;Callback1&quot;, arguments: [null]}, success: {name: &quot;Callback1&quot;, arguments: [null]}, ip: &quot;InquiryPacket&quot;}, {});
var AssertionProcessor = function() {
    this.repositories = new Array();
    this.step = AssertionProcessor.DEF_STEP;
};
AssertionProcessor = stjs.extend(AssertionProcessor, null, [], function(constructor, prototype) {
    prototype.repositories = null;
    prototype.step = false;
    prototype.logFunction = null;
    constructor.DEF_STEP = false;
    prototype.processedEquivalencies = null;
    prototype.log = function(ip, string) {
        if (this.logFunction != null) 
            this.logFunction(string);
        ip.log += &quot;\n&quot; + string;
    };
    prototype.has = function(subject, competency, level, context, additionalSignatures, success, ask, failure) {
        var ip = new InquiryPacket(subject, competency, level, context, success, failure, null, InquiryPacket.IPType.COMPETENCY);
        this.processedEquivalencies = {};
        this.log(ip, &quot;Created new inquiry.&quot;);
        this.continueProcessing(ip);
    };
    prototype.isIn = function(ip, alreadyDone) {
        for (var i = 0; i &lt; alreadyDone.length; i++) 
            if (ip == alreadyDone[i]) 
                return true;
        return false;
    };
    prototype.continueProcessing = function(ip) {
        if (!ip.finished) {
            if (!ip.hasCheckedAssertionsForCompetency) {
                this.findSubjectAssertionsForCompetency(ip);
                return true;
            } else if (!ip.hasCheckedRelationshipsForCompetency) {
                this.findCompetencyRelationships(ip);
                return true;
            } else if (!ip.hasCheckedRollupRulesForCompetency) {
                this.findRollupRulesForCompetency(ip);
                return true;
            } else {
                ip.finished = true;
            }
        }
        if (ip.finished) {
            if (this.processChildPackets(ip.equivalentPackets)) 
                return true;
            if (this.processChildPackets(ip.subPackets)) 
                return true;
        }
        if (ip.result == null) {
            this.determineResult(ip);
            if (ip.result != null &amp;&amp; ip.success != null) 
                ip.success(ip);
            return true;
        }
        return false;
    };
    prototype.determineResult = function(ip) {};
    prototype.findCompetencyRelationships = function(ip) {};
    prototype.findSubjectAssertionsForCompetency = function(ip) {};
    prototype.processChildPackets = function(childPackets) {
        if (childPackets != null) {
            for (var i = 0; i &lt; childPackets.length; i++) {
                if (this.continueProcessing(childPackets[i])) 
                    return true;
            }
        }
        return false;
    };
    prototype.checkStep = function(ip) {
        this.log(ip, &quot;Checkstep: &quot; + ip.numberOfQueriesRunning);
        if (ip.numberOfQueriesRunning == 0) {
            if (!this.step) 
                this.continueProcessing(ip);
        }
    };
    prototype.processEventFailure = function(message, ip) {
        this.log(ip, &quot;Event failed: &quot; + message);
        ip.numberOfQueriesRunning--;
        ip.failure(message);
    };
    prototype.logFoundAssertion = function(a, ip) {
        this.log(ip, &quot;No issues found with assertion.&quot;);
        this.log(ip, &quot;Record Id: &quot; + a.shortId());
        this.log(ip, &quot;Confidence: &quot; + a.confidence);
        this.log(ip, &quot;Number of pieces of evidence: &quot; + a.getEvidenceCount());
        this.log(ip, &quot;Evidence:&quot;);
        for (var j = 0; j &lt; a.getEvidenceCount(); j++) 
            this.log(ip, &quot;  &quot; + a.getEvidence(j));
        this.log(ip, &quot;Recording in inquiry.&quot;);
    };
    prototype.buildAssertionSearchQuery = function(ip, competency) {
        if (InquiryPacket.IPType.ROLLUPRULE.equals(ip.type)) 
            return &quot;(&quot; + new EcAssertion().getSearchStringByType() + &quot;) AND (&quot; + ip.rule + &quot;)&quot;;
         else if (InquiryPacket.IPType.COMPETENCY.equals(ip.type)) 
            return new EcAssertion().getSearchStringByTypeAndCompetency(competency);
         throw new RuntimeException(&quot;Trying to build an assertion search query on an unsupported type: &quot; + ip.type);
    };
    prototype.processRelationshipPacketsGenerated = function(ip, competency) {
        this.log(ip, &quot;Relationships succesfully processed for: &quot; + competency.id);
        ip.numberOfQueriesRunning--;
        this.checkStep(ip);
    };
    prototype.processRollupRuleInterpretSuccess = function(status, ip) {
        this.log(ip, &quot;Rollup rule successfully interpreted.&quot;);
        ip.numberOfQueriesRunning--;
        ip.status = status;
        this.checkStep(ip);
    };
    prototype.processRollupRuleInterpretSkipped = function(ip) {
        this.log(ip, &quot;Rollup rule skipped.&quot;);
        ip.numberOfQueriesRunning--;
        this.checkStep(ip);
    };
    prototype.findRollupRulesForCompetency = function(ip) {
        ip.hasCheckedRollupRulesForCompetency = true;
        if (!InquiryPacket.IPType.COMPETENCY.equals(ip.type)) {
            this.log(ip, &quot;No rollup rules for combinator types&quot;);
            this.checkStep(ip);
            return;
        }
        var ep = this;
        if (ip.getContext().rollupRule == null) 
            this.continueProcessing(ip);
         else 
            for (var i = 0; i &lt; ip.getContext().rollupRule.length; i++) {
                ip.numberOfQueriesRunning++;
                EcRollupRule.get(ip.getContext().rollupRule[i], function(rr) {
                    ep.processFindRollupRuleSuccess(rr, ip);
                }, function(p1) {
                    ep.processEventFailure(p1, ip);
                });
            }
    };
    prototype.processFindRollupRuleSuccess = function(rr, ip) {};
}, {repositories: {name: &quot;Array&quot;, arguments: [&quot;EcRepository&quot;]}, logFunction: {name: &quot;Callback1&quot;, arguments: [&quot;Object&quot;]}, processedEquivalencies: {name: &quot;Map&quot;, arguments: [null, null]}}, {});
var RollupRuleProcessor = function(ip, ep) {
    this.ip = ip;
    this.rollupRulePacketGenerator = new RollupRulePacketGenerator(ip, ep);
};
RollupRuleProcessor = stjs.extend(RollupRuleProcessor, null, [], function(constructor, prototype) {
    prototype.onQueryExitResult = null;
    prototype.query = null;
    prototype.success = null;
    prototype.failure = null;
    prototype.logFunction = null;
    prototype.positive = null;
    prototype.negative = null;
    prototype.s = null;
    prototype.tok = null;
    prototype.que = null;
    prototype.ip = null;
    prototype.rollupRulePacketGenerator = null;
    prototype.log = function(string) {
        if (this.logFunction != null) 
            this.logFunction(string);
    };
    prototype.enterS = function(ctx) {
        if (this.s != null) 
             throw new RuntimeException(&quot;We found another S in our S.&quot;);
        this.s = new RrS();
    };
    prototype.exitS = function(ctx) {
        this.ip.subPackets.push(this.rollupRulePacketGenerator.generatePacket());
    };
    prototype.enterToken = function(ctx) {
        this.s.addToken(this.tok = new RrToken());
    };
    prototype.exitToken = function(ctx) {};
    prototype.enterQuery = function(ctx) {
        this.s.addQuery(this.que = new RrQuery());
        this.query = &quot;&quot;;
        this.onQueryExitResult = null;
    };
    prototype.exitQuery = function(ctx) {
        this.que.query = this.query.trim();
        this.log(&quot;ADDING QUERY: &quot; + this.query.trim());
        this.rollupRulePacketGenerator.addQuery(this.query.trim());
    };
    prototype.exitInnerquery = function(ctx) {
        if (ctx.cLogic != null) 
            this.query += &quot; &quot; + ctx.cLogic.text + &quot; &quot;;
        if (ctx.cValue != null) {
            this.query += ctx.cKey.text + &quot;&quot; + ctx.cOperator.text + &quot;\&quot;&quot; + ctx.cValue.text + &quot;\&quot; &quot;;
        }
        if (ctx.cNumber != null) {
            this.query += ctx.cKey.text + &quot;&quot; + ctx.cOperator.text + &quot;&quot; + ctx.cNumber.text + &quot; &quot;;
        }
    };
    prototype.exitLogical_or_math_operator = function(ctx) {
        if (ctx.cLogic != null) {
            if (&quot;AND&quot;.equals(ctx.cLogic.text.toUpperCase())) {
                this.log(&quot;ADDING OPERATION: &quot; + RollupRulePacketGenerator.OperationType.AND);
                this.rollupRulePacketGenerator.addQueryOperation(RollupRulePacketGenerator.OperationType.AND);
            } else if (&quot;OR&quot;.equals(ctx.cLogic.text.toUpperCase())) {
                this.log(&quot;ADDING OPERATION: &quot; + RollupRulePacketGenerator.OperationType.OR);
                this.rollupRulePacketGenerator.addQueryOperation(RollupRulePacketGenerator.OperationType.OR);
            }
        }
    };
}, {success: {name: &quot;Callback1&quot;, arguments: [null]}, failure: {name: &quot;Callback1&quot;, arguments: [null]}, logFunction: {name: &quot;Callback1&quot;, arguments: [&quot;Object&quot;]}, positive: {name: &quot;Array&quot;, arguments: [&quot;EcAssertion&quot;]}, negative: {name: &quot;Array&quot;, arguments: [&quot;EcAssertion&quot;]}, s: &quot;RrS&quot;, tok: &quot;RrToken&quot;, que: &quot;RrQuery&quot;, ip: &quot;InquiryPacket&quot;, rollupRulePacketGenerator: &quot;RollupRulePacketGenerator&quot;}, {});
var CombinatorAssertionProcessor = function() {
    AssertionProcessor.call(this);
};
CombinatorAssertionProcessor = stjs.extend(CombinatorAssertionProcessor, AssertionProcessor, [], function(constructor, prototype) {
    prototype.processFoundAssertion = function(searchData, ip) {
        var a = new EcAssertion();
        a.copyFrom(searchData);
        var currentSubject;
        for (var i = 0; i &lt; ip.subject.length; i++) {
            currentSubject = ip.subject[i];
            if (a.getSubject() == null) 
                continue;
            if (a.getSubject().equals(currentSubject)) {
                this.log(ip, &quot;Matching Assertion found.&quot;);
                var assertionDate = a.getAssertionDate();
                if (assertionDate != null) 
                    if (assertionDate &gt; stjs.trunc(new Date().getTime())) {
                        this.log(ip, &quot;Assertion is made for a future date.&quot;);
                        return;
                    } else {
                        var expirationDate = a.getExpirationDate();
                        if (expirationDate != null) 
                            if (expirationDate &lt;= stjs.trunc(new Date().getTime())) {
                                this.log(ip, &quot;Assertion is expired. Skipping.&quot;);
                                return;
                            }
                    }
                this.logFoundAssertion(a, ip);
                if (a.getNegative()) {
                    this.log(ip, &quot;Found valid negative assertion&quot;);
                    ip.negative.push(a);
                } else {
                    this.log(ip, &quot;Found valid positive assertion&quot;);
                    ip.positive.push(a);
                }
            }
        }
    };
    prototype.processFindAssertionsSuccess = function(data, ip) {
        if (data.length == 0) 
            this.log(ip, &quot;No results found.&quot;);
         else 
            this.log(ip, &quot;Total number of assertions found: &quot; + data.length);
        ip.numberOfQueriesRunning--;
        this.checkStep(ip);
    };
    prototype.findSubjectAssertionsForCompetency = function(ip) {
        ip.hasCheckedAssertionsForCompetency = true;
        if (!InquiryPacket.IPType.COMPETENCY.equals(ip.type) &amp;&amp; !InquiryPacket.IPType.ROLLUPRULE.equals(ip.type)) {
            this.log(ip, &quot;No assertions for combinator types&quot;);
            this.checkStep(ip);
            return;
        }
        var ep = this;
        for (var i = 0; i &lt; this.repositories.length; i++) {
            var currentRepository = this.repositories[i];
            if (InquiryPacket.IPType.COMPETENCY.equals(ip.type)) 
                this.log(ip, &quot;Searching: &quot; + currentRepository.selectedServer);
            for (var h = 0; h &lt; ip.competency.length; h++) {
                ip.numberOfQueriesRunning++;
                var competency = ip.competency[h];
                this.log(ip, &quot;Querying repositories for subject assertions on competency: &quot; + competency.id);
                currentRepository.search(this.buildAssertionSearchQuery(ip, competency), function(p1) {
                    ep.processFoundAssertion(p1, ip);
                }, function(p1) {
                    ep.processFindAssertionsSuccess(p1, ip);
                }, function(p1) {
                    ep.processEventFailure(p1, ip);
                });
            }
            if (InquiryPacket.IPType.ROLLUPRULE.equals(ip.type)) {
                ip.numberOfQueriesRunning++;
                this.log(ip, &quot;Searching: &quot; + currentRepository.selectedServer);
                currentRepository.search(this.buildAssertionSearchQuery(ip, null), function(p1) {
                    ep.processFoundAssertion(p1, ip);
                }, function(p1) {
                    ep.processFindAssertionsSuccess(p1, ip);
                }, function(p1) {
                    ep.processEventFailure(p1, ip);
                });
            }
        }
    };
    prototype.findCompetencyRelationships = function(ip) {
        ip.hasCheckedRelationshipsForCompetency = true;
        if (!InquiryPacket.IPType.COMPETENCY.equals(ip.type)) {
            this.log(ip, &quot;No relationships for combinator types&quot;);
            this.checkStep(ip);
            return;
        }
        var ep = this;
        for (var i = 0; i &lt; ip.competency.length; i++) {
            this.log(ip, &quot;Finding relationships for competency: &quot; + ip.competency[i]);
            this.findCompetencyRelationship(ip, ep, ip.competency[i]);
        }
    };
    prototype.findCompetencyRelationship = function(ip, ep, c) {
        var rpg = new RelationshipPacketGenerator(ip, ep, this.processedEquivalencies);
        rpg.failure = ip.failure;
        rpg.logFunction = this.logFunction;
        rpg.success = function() {
            ep.processRelationshipPacketsGenerated(ip, c);
        };
        this.log(ip, &quot;Executing relationship packet generator&quot;);
        ip.numberOfQueriesRunning++;
        rpg.go();
    };
    prototype.processFindRollupRuleSuccess = function(rr, ip) {
        var ep = this;
        if (!ip.hasId(rr.competency)) {
            ep.processRollupRuleInterpretSkipped(ip);
            return;
        }
        this.log(ip, &quot;Found rollup rule: &quot; + rr.rule);
        var rrp = new RollupRuleProcessor(ip, this);
        rrp.positive = ip.positive;
        rrp.negative = ip.negative;
        var rri = new RollupRuleInterface(rr.rule, rrp);
        rri.logFunction = this.logFunction;
        rri.success = function(p1) {
            ep.processRollupRuleInterpretSuccess(p1, ip);
        };
        rri.failure = ip.failure;
        this.log(ip, &quot;Executing rollup rule interpreter&quot;);
        rri.go();
    };
}, {repositories: {name: &quot;Array&quot;, arguments: [&quot;EcRepository&quot;]}, logFunction: {name: &quot;Callback1&quot;, arguments: [&quot;Object&quot;]}, processedEquivalencies: {name: &quot;Map&quot;, arguments: [null, null]}}, {});
var PessimisticQuadnaryAssertionProcessor = function() {
    CombinatorAssertionProcessor.call(this);
};
PessimisticQuadnaryAssertionProcessor = stjs.extend(PessimisticQuadnaryAssertionProcessor, CombinatorAssertionProcessor, [], function(constructor, prototype) {
    prototype.transferIndeterminateOptimistically = true;
    prototype.determineCombinatorAndResult = function(ip) {
        if (ip.anyChildPacketsAreFalse()) 
            ip.result = InquiryPacket.ResultType.FALSE;
         else if (ip.anyIndeterminantChildPackets()) 
            ip.result = InquiryPacket.ResultType.INDETERMINANT;
         else if (ip.anyChildPacketsAreUnknown()) 
            ip.result = InquiryPacket.ResultType.UNKNOWN;
         else 
            ip.result = InquiryPacket.ResultType.TRUE;
    };
    prototype.determineCombinatorNarrowsResult = function(ip) {
        if (ip.anyChildPacketsAreTrue()) 
            ip.result = InquiryPacket.ResultType.TRUE;
         else if (this.transferIndeterminateOptimistically &amp;&amp; ip.anyIndeterminantChildPackets()) 
            ip.result = InquiryPacket.ResultType.FALSE;
         else 
            ip.result = InquiryPacket.ResultType.UNKNOWN;
    };
    prototype.determineCombinatorBroadensResult = function(ip) {
        if (ip.anyChildPacketsAreFalse()) 
            ip.result = InquiryPacket.ResultType.FALSE;
         else if (this.transferIndeterminateOptimistically &amp;&amp; ip.anyIndeterminantChildPackets()) 
            ip.result = InquiryPacket.ResultType.TRUE;
         else 
            ip.result = InquiryPacket.ResultType.UNKNOWN;
    };
    prototype.determineCombinatorRequiresResult = function(ip) {
        if (ip.anyChildPacketsAreFalse()) 
            ip.result = InquiryPacket.ResultType.FALSE;
         else if (this.transferIndeterminateOptimistically &amp;&amp; ip.anyIndeterminantChildPackets()) 
            ip.result = InquiryPacket.ResultType.TRUE;
         else 
            ip.result = InquiryPacket.ResultType.UNKNOWN;
    };
    prototype.determineCombinatorIsRequiredByResult = function(ip) {
        if (ip.anyChildPacketsAreTrue()) 
            ip.result = InquiryPacket.ResultType.TRUE;
         else if (this.transferIndeterminateOptimistically &amp;&amp; ip.anyIndeterminantChildPackets()) 
            ip.result = InquiryPacket.ResultType.FALSE;
         else 
            ip.result = InquiryPacket.ResultType.UNKNOWN;
    };
    prototype.determineCombinatorOrResult = function(ip) {
        if (ip.anyChildPacketsAreTrue()) 
            ip.result = InquiryPacket.ResultType.TRUE;
         else if (ip.anyIndeterminantChildPackets()) 
            ip.result = InquiryPacket.ResultType.INDETERMINANT;
         else if (ip.allChildPacketsUnknown()) 
            ip.result = InquiryPacket.ResultType.UNKNOWN;
         else 
            ip.result = InquiryPacket.ResultType.FALSE;
    };
    prototype.getPacketAssertionResult = function(ip) {
        if (ip.positive.length &gt; 0 &amp;&amp; ip.negative.length == 0) 
            return InquiryPacket.ResultType.TRUE;
         else if (ip.positive.length == 0 &amp;&amp; ip.negative.length &gt; 0) 
            return InquiryPacket.ResultType.FALSE;
         else if (ip.positive.length &gt; 0 &amp;&amp; ip.negative.length &gt; 0) 
            return InquiryPacket.ResultType.INDETERMINANT;
         else 
            return InquiryPacket.ResultType.UNKNOWN;
    };
    prototype.determineResultForUnknownAssertionResult = function(ip) {
        if (ip.allChildPacketsUnknown()) 
            ip.result = InquiryPacket.ResultType.UNKNOWN;
         else if (ip.allEquivalentPacketsUnknown()) {
            if (ip.allSubPacketsTrueOrUnknown()) 
                ip.result = InquiryPacket.ResultType.TRUE;
             else if (ip.allSubPacketsFalseOrUnknown()) 
                ip.result = InquiryPacket.ResultType.FALSE;
             else 
                ip.result = InquiryPacket.ResultType.INDETERMINANT;
        } else if (ip.allEquivalentPacketsTrueOrUnknown()) {
            if (ip.allSubPacketsTrueOrUnknown()) 
                ip.result = InquiryPacket.ResultType.TRUE;
             else 
                ip.result = InquiryPacket.ResultType.INDETERMINANT;
        } else if (ip.allEquivalentPacketsFalseOrUnknown()) {
            if (ip.allSubPacketsFalseOrUnknown()) 
                ip.result = InquiryPacket.ResultType.FALSE;
             else 
                ip.result = InquiryPacket.ResultType.INDETERMINANT;
        } else 
            ip.result = InquiryPacket.ResultType.INDETERMINANT;
    };
    prototype.determineResultForTrueAssertionResult = function(ip) {
        if (ip.allEquivalentPacketsTrueOrUnknown()) {
            if (ip.allSubPacketsTrueOrUnknown()) 
                ip.result = InquiryPacket.ResultType.TRUE;
             else 
                ip.result = InquiryPacket.ResultType.INDETERMINANT;
        } else 
            ip.result = InquiryPacket.ResultType.INDETERMINANT;
    };
    prototype.determineResultForFalseAssertionResult = function(ip) {
        if (ip.allEquivalentPacketsFalseOrUnknown()) {
            if (ip.allSubPacketsFalseOrUnknown()) 
                ip.result = InquiryPacket.ResultType.FALSE;
             else 
                ip.result = InquiryPacket.ResultType.INDETERMINANT;
        } else 
            ip.result = InquiryPacket.ResultType.INDETERMINANT;
    };
    /**
     *  IF IP type is COMPETENCY|ROLLUPRULE: assertionResult = ( IF number of
     *  positive assertions &gt; 0 &amp;&amp; number of negative assertions = 0 THEN
     *  assertionResult = TRUE IF number of positive assertions = 0 &amp;&amp; number of
     *  negative assertions &gt; 0 THEN assertionResult = FALSE IF number of
     *  positive assertions &gt; 0 &amp;&amp; number of negative assertions &gt; 0 THEN
     *  assertionResult = INDETERMINANT IF number of positive assertions = 0 &amp;&amp;
     *  number of negative assertions = 0 THEN assertionResult = UNKNOWN )
     *  
     *  IF assertionResult = INDETERMINANT THEN INDETERMINANT ELSE IF any
     *  equivalent packets = INDETERMINANT THEN INDETERMINANT ELSE IF any sub
     *  packets = INDETERMINANT THEN INDETERMINANT
     *  
     *  ELSE IF assertionResult = UNKNOWN: IF all equivalent packets = UNKNOWN IF
     *  all sub packets = UNKNOWN THEN UNKNOWN IF all sub packets = TRUE|UNKNOWN
     *  THEN TRUE IF all sub packets = FALSE|UNKNOWN THEN FALSE ELSE
     *  INDETERMINANT
     *  
     *  ELSE IF all equivalent packets = TRUE|UNKNOWN IF all sub packets =
     *  TRUE|UNKNOWN THEN TRUE ELSE INDETERMINANT
     *  
     *  ELSE IF all equivalent packets = FALSE|UNKNOWN IF all sub packets =
     *  FALSE|UNKNOWN THEN FALSE ELSE INDETERMINANT
     *  
     *  ELSE INDETERMINANT
     *  
     *  
     *  ELSE IF assertionResult = TRUE: IF all equivalent packets = TRUE|UNKNOWN
     *  IF all sub packets = TRUE|UNKNOWN THEN TRUE ELSE INDETERMINANT
     *  
     *  ELSE INDETERMINANT
     *  
     *  ELSE IF assertionResult = FALSE: IF all equivalent packets =
     *  FALSE|UNKNOWN IF all sub packets = FALSE|UNKNOWN THEN FALSE ELSE
     *  INDETERMINANT
     *  
     *  ELSE INDETERMINANT
     *  
     */
    prototype.determineCompetencyOrRollupRuleResult = function(ip) {
        var assertionResult = this.getPacketAssertionResult(ip);
        if (InquiryPacket.ResultType.INDETERMINANT.equals(assertionResult) || ip.anyIndeterminantChildPackets()) 
            ip.result = InquiryPacket.ResultType.INDETERMINANT;
         else if (InquiryPacket.ResultType.UNKNOWN.equals(assertionResult)) 
            this.determineResultForUnknownAssertionResult(ip);
         else if (InquiryPacket.ResultType.TRUE.equals(assertionResult)) 
            this.determineResultForTrueAssertionResult(ip);
         else 
            this.determineResultForFalseAssertionResult(ip);
    };
    prototype.determineResult = function(ip) {
        if (ip.numberOfQueriesRunning == 0) {
            if (InquiryPacket.IPType.RELATION_AND.equals(ip.type)) 
                this.determineCombinatorAndResult(ip);
             else if (InquiryPacket.IPType.RELATION_OR.equals(ip.type)) 
                this.determineCombinatorOrResult(ip);
             else if (InquiryPacket.IPType.RELATION_NARROWS.equals(ip.type)) 
                this.determineCombinatorNarrowsResult(ip);
             else if (InquiryPacket.IPType.RELATION_BROADENS.equals(ip.type)) 
                this.determineCombinatorBroadensResult(ip);
             else if (InquiryPacket.IPType.RELATION_REQUIRES.equals(ip.type)) 
                this.determineCombinatorRequiresResult(ip);
             else if (InquiryPacket.IPType.RELATION_ISREQUIREDBY.equals(ip.type)) 
                this.determineCombinatorIsRequiredByResult(ip);
             else 
                this.determineCompetencyOrRollupRuleResult(ip);
        } else {
            this.log(ip, &quot;We are not finished accumulating data to answer this query. Error: &quot; + ip.numberOfQueriesRunning);
        }
    };
}, {repositories: {name: &quot;Array&quot;, arguments: [&quot;EcRepository&quot;]}, logFunction: {name: &quot;Callback1&quot;, arguments: [&quot;Object&quot;]}, processedEquivalencies: {name: &quot;Map&quot;, arguments: [null, null]}}, {});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
