<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>ec.ui.framework.js - CASS Javascript Library</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="http://www.cassproject.org/_/rsrc/1451948061999/config/customLogo.gif?revision=16" title="CASS Javascript Library"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Action.html">Action</a></li>
                                <li><a href="../classes/AlignmentObject.html">AlignmentObject</a></li>
                                <li><a href="../classes/CreativeWork.html">CreativeWork</a></li>
                                <li><a href="../classes/Ebac.html">Ebac</a></li>
                                <li><a href="../classes/EcAes.html">EcAes</a></li>
                                <li><a href="../classes/EcAesCtr.html">EcAesCtr</a></li>
                                <li><a href="../classes/EcAesCtrAsync.html">EcAesCtrAsync</a></li>
                                <li><a href="../classes/EcArray.html">EcArray</a></li>
                                <li><a href="../classes/EcAsyncHelper.html">EcAsyncHelper</a></li>
                                <li><a href="../classes/EcDirectedGraph.html">EcDirectedGraph</a></li>
                                <li><a href="../classes/EcLinkedData.html">EcLinkedData</a></li>
                                <li><a href="../classes/EcObject.html">EcObject</a></li>
                                <li><a href="../classes/EcPk.html">EcPk</a></li>
                                <li><a href="../classes/EcPpk.html">EcPpk</a></li>
                                <li><a href="../classes/EcRemote.html">EcRemote</a></li>
                                <li><a href="../classes/EcRemoteLinkedData.html">EcRemoteLinkedData</a></li>
                                <li><a href="../classes/EcRsaOaep.html">EcRsaOaep</a></li>
                                <li><a href="../classes/EcRsaOaepAsync.html">EcRsaOaepAsync</a></li>
                                <li><a href="../classes/General.html">General</a></li>
                                <li><a href="../classes/Graph.html">Graph</a></li>
                                <li><a href="../classes/Hypergraph.html">Hypergraph</a></li>
                                <li><a href="../classes/Person.html">Person</a></li>
                                <li><a href="../classes/Triple.html">Triple</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: ec.ui.framework.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
 Copyright 2015-2016 Eduworks Corporation and other contributing parties.

 Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
*/
/**
 *  Parent class of all view manager classes, stores a cache of the views and
 *  their corresponding DOM selectors and provides functions for setting a view
 *  to correspond to a selector and displaying a view after it has been added to
 *  the cache.
 *  
 *  @author devlin.junker@eduworks.com
 */
var ViewManager = function() {};
ViewManager = stjs.extend(ViewManager, null, [], function(constructor, prototype) {
    /**
     *  Storage that maps view class instances to DOM Elements
     */
    constructor.viewMap = {};
    /**
     *  Set&#x27;s the view instance for a specific DOM selector
     *  
     *  @param containerId
     *             DOM Selector for the element that will correspond to the view
     *  @param view
     *             View that will correspond to the DOM Selector
     */
    constructor.setView = function(containerId, view) {
        ViewManager.viewMap[containerId] = view;
    };
    /**
     *  Returns the view instance that currently corresponds to a specific DOM
     *  selector
     *  
     *  @param containerId
     *             DOM Selector that corresponds to the view to be returned
     *  @return The view that corresponds to the DOM Selector passed in, or null
     *          if no view corresponds with it
     */
    constructor.getView = function(containerId) {
        return ViewManager.viewMap[containerId];
    };
    /**
     *  Relates the view to a DOM Selector and calls the view&#x27;s display function
     *  to populate the inner html of the DOM Selector Element
     *  
     *  @param view
     *             View to be displayed in the DOM Selector Element
     *  @param containerId
     *             DOM Selector for element that the view will be displayed in
     *  @param callback
     *             Callback function to be passed in to the view&#x27;s display
     *             function (to be called once the view has been displayed)
     */
    constructor.showView = function(view, containerId, callback) {
        var htmlLocation = view.getHtmlLocation();
        if (htmlLocation != null) {
            ViewManager.setView(containerId, view);
            $(containerId).load(htmlLocation, null, function(p1, p2, p3) {
                view.display(containerId);
                if (callback != null) 
                    callback();
            });
        }
        $(containerId).removeClass(&quot;hide&quot;);
    };
    /**
     *  Hides the container specified by the containerId by adding &#x27;hide&#x27; class
     *  
     *  @param containerId
     *             DOM Selector for the element to add the &#x27;hide&#x27; class to
     */
    constructor.hideView = function(containerId) {
        $(containerId).addClass(&quot;hide&quot;);
    };
}, {viewMap: {name: &quot;Map&quot;, arguments: [null, &quot;EcView&quot;]}}, {});
/**
 *  Object stored in the ScreenManager&#x27;s history cache array, to keep track of the history of screens and 
 *  which DOM element they were displayed in
 *  
 *  @author devlin.junker@eduworks.com
 */
var HistoryClosure = /**
 *  Constructor for the HistoryClosure Object
 *  
 *  @param name
 *  			Page Name associated with this page (used for loading history screens)
 *  @param screen
 *  			Screen to associate with the page name (to display when loading history screens)
 *  @param containerId
 *  			DOM Selector (ID) of the HTML container to display the screen in on load history
 */
function(name, screen, containerId, params) {
    this.pageName = name;
    this.screen = screen;
    this.containerId = containerId;
    this.screenParameters = params;
};
HistoryClosure = stjs.extend(HistoryClosure, null, [], function(constructor, prototype) {
    /**
     *  Name of the page (used to retrieve the correct screen on a back/forward button press)
     */
    prototype.pageName = null;
    /**
     *  Screen to store and associate with the page name so that it can be loaded if necessary
     */
    prototype.screen = null;
    /**
     *  ID of the container to display the screen in, once it has been found by page name
     */
    prototype.containerId = null;
    prototype.screenParameters = null;
}, {screen: &quot;EcScreen&quot;, screenParameters: &quot;Object&quot;}, {});
/**
 *  Class that represents a &quot;view&quot; that can be displayed in an container element on the page. The View should define 
 *  a display function that loads HTML into the container element on the page and then finally calls the callback once
 *  the view has been completely initialized
 *  
 *  @author devlin.junker@eduworks.com
 */
var EcView = function() {};
EcView = stjs.extend(EcView, null, [], function(constructor, prototype) {
    /**
     *  Function to be defined in subclasses that returns the location of the main html file associated with this view
     *  
     *  @return
     *  			The string path to an html file
     */
    prototype.getHtmlLocation = function() {};
    /**
     *  Display function to override (usually in JavaScript) that will set up any event handlers
     */
    prototype.display = function(containerId) {
        console.error(&quot;Not Implemented&quot;);
    };
    /**
     *  Function that will convert a view to a certain other view class as long as it the converted type inherits the
     *  current type of the view
     *  
     *  @param _interface
     *  			Class type that the instance should be converted to
     *  @return
     *  			The converted instance of the type passed in
     */
    prototype.as = function(_interface) {
        var prototype = (this)[&quot;__proto__&quot;];
        var constructor = (prototype)[&quot;constructor&quot;];
        var inherits = (constructor)[&quot;$inherit&quot;];
        if (inherits != null) 
            for (var i = 0; i &lt; inherits.length; i++) {
                if (inherits[i] == _interface) {
                    return this;
                }
            }
        return null;
    };
    prototype.getUrlParameters = function() {
        return EcView.urlParameters();
    };
    constructor.urlParameters = function() {
        var hashSplit = (window.document.location.hash.split(&quot;?&quot;));
        if (hashSplit.length &gt; 1) {
            var o = null;
            var params = (o = new Object());
            var paramString = hashSplit[1];
            var parts = (paramString).split(&quot;&amp;&quot;);
            for (var i = 0; i &lt; parts.length; i++) 
                params[parts[i].split(&quot;=&quot;)[0]] = parts[i].replace(parts[i].split(&quot;=&quot;)[0] + &quot;=&quot;, &quot;&quot;);
            return o;
        }
        return new Object();
    };
}, {}, {});
/**
 *  STJS Wrapper for the Browser Native History Object
 *  
 *  @author devlin.junker@eduworks.com
 */
var HistoryObject = function() {};
HistoryObject = stjs.extend(HistoryObject, null, [], function(constructor, prototype) {
    prototype.name = null;
}, {}, {});
/**
 *  View Manager sub class that manages loading &quot;modal&quot;s and has a few helper functions to make sure that 
 *  they work properly
 *  
 *  @author djunker
 */
var ModalManager = function() {
    ViewManager.call(this);
};
ModalManager = stjs.extend(ModalManager, ViewManager, [], function(constructor, prototype) {
    /**
     *  DOM Selector (ID) of the container to display Modal&#x27;s in
     */
    constructor.MODAL_CONTAINER_ID = &quot;#modalContainer&quot;;
    /**
     *  Application flag that is set when a modal is open, so we can check from the application whether we&#x27;re in a 
     *  modal or not.
     */
    constructor.inModal = false;
    /**
     *  Retrieves the current view that corresponds to the Modal Container Element (Should be a Modal)
     *  
     *  @return
     *  		EcModal instance that is currently being shown in the Modal container element
     */
    constructor.getCurrentModal = function() {
        return ViewManager.getView(ModalManager.MODAL_CONTAINER_ID);
    };
    /**
     *  Sets the current modal and then shows it by calling the modals display function
     *   
     *  @param modal
     *  			Modal Instance to be displayed in the modal container and set as current
     *  @param callback
     *  			Function to invoke after the modal has been displayed
     */
    constructor.showModal = function(modal, callback) {
        $(ModalManager.MODAL_CONTAINER_ID).removeClass(&quot;tiny&quot;);
        $(ModalManager.MODAL_CONTAINER_ID).removeClass(&quot;small&quot;);
        $(ModalManager.MODAL_CONTAINER_ID).removeClass(&quot;medium&quot;);
        $(ModalManager.MODAL_CONTAINER_ID).removeClass(&quot;large&quot;);
        $(ModalManager.MODAL_CONTAINER_ID).removeClass(&quot;full&quot;);
        var modalSize = modal.getModalSize();
        if (modalSize.equals(&quot;tiny&quot;) || modalSize.equals(&quot;small&quot;) || modalSize.equals(&quot;medium&quot;) || modalSize.equals(&quot;large&quot;) || modalSize.equals(&quot;full&quot;)) {
            $(ModalManager.MODAL_CONTAINER_ID).addClass(modalSize);
        } else {
            $(ModalManager.MODAL_CONTAINER_ID).addClass(&quot;small&quot;);
        }
        ViewManager.showView(modal, ModalManager.MODAL_CONTAINER_ID, function() {
            ($(ModalManager.MODAL_CONTAINER_ID)).foundation();
            ($(ModalManager.MODAL_CONTAINER_ID)).foundation(&quot;open&quot;);
            ModalManager.inModal = true;
            if (callback != null) {
                callback();
            }
        });
    };
    /**
     *  Hides the modal container and returns to the screen or overlay that was being displayed beneath it
     */
    constructor.hideModal = function() {
        ($(ModalManager.MODAL_CONTAINER_ID)).foundation(&quot;close&quot;);
        ModalManager.inModal = false;
    };
}, {viewMap: {name: &quot;Map&quot;, arguments: [null, &quot;EcView&quot;]}}, {});
(function() {
    $(ModalManager.MODAL_CONTAINER_ID).one(&quot;closed.zf.reveal&quot;, function(arg0, arg1) {
        if (ModalManager.getCurrentModal().onClose != null) 
            ModalManager.getCurrentModal().onClose();
        return true;
    });
})();
/**
 *  View Subclass representing modal views that are displayed in the modal container
 *  
 *  @author devlin.junker@eduworks.com
 */
var EcModal = function() {
    EcView.call(this);
};
EcModal = stjs.extend(EcModal, EcView, [], function(constructor, prototype) {
    /**
     *  To be overrided in subclasses, lets the developer define the size of the modal
     */
    prototype.modalSize = &quot;small&quot;;
    /**
     *  Function to be invoked when the modal is closed, can be overriden or left blank if nothing
     *  needs to happen on the modal close 
     */
    prototype.onClose = null;
    /**
     *  @return tiny, small, medium, large, or full depending on how large the modal should be
     */
    prototype.getModalSize = function() {};
}, {onClose: &quot;Callback0&quot;}, {});
/**
 *  Subclass of view that is specific for a screen, providing a display name that
 *  will be shown in the URL bar and that can be used on startup to check if the
 *  URL is asking for a certain page on startup.
 *  
 *  @author devlin.junker@eduworks.com
 */
var EcScreen = function() {
    EcView.call(this);
};
EcScreen = stjs.extend(EcScreen, EcView, [], function(constructor, prototype) {
    /**
     *  Name that identifies a certain type of screen, shown in the URL bar to
     *  help the user understand the page that they are on and used during
     *  startup to decide whether or not to load a specifici page on startup.
     */
    prototype.displayName = &quot;&quot;;
    /**
     *  Getter for the display name
     *  
     *  @return The display name for the screen
     */
    prototype.getDisplayName = function() {
        return this.displayName;
    };
    prototype.setData = function(data) {};
}, {}, {});
/**
 *  View Manager child class that manages loading &quot;screen&quot;s and saving screen history. This is the main view type
 *  in an application and represents a view that takes up (mostly) the entire browser page. History is tracked in the
 *  session, so  when the back button is pressed, the application will load the previous screen with any data that 
 *  was associated with it.
 *  
 *  @author devlin.junker@eduworks.com
 */
var ScreenManager = function() {
    ViewManager.call(this);
};
ScreenManager = stjs.extend(ScreenManager, ViewManager, [], function(constructor, prototype) {
    /**
     *  DOM Selector (ID) of the Screen Container that will display all of the screen views
     */
    constructor.SCREEN_CONTAINER_ID = &quot;#screenContainer&quot;;
    /**
     *  Array to track the history of the current session
     */
    constructor.myHistory = [];
    /**
     *  Screen to be used when another screen is loading information from the server before being able to display
     *  itself. Notice that the display function does not affect the DOM on the page in any way.
     */
    constructor.LOADING_STARTUP_PAGE = new (stjs.extend(function ScreenManager$1() {
        EcScreen.call(this);
    }, EcScreen, [], function(constructor, prototype) {
        prototype.getHtmlLocation = function() {
            return null;
        };
    }, {}, {}))();
    /**
     *  Screen to be set by application on application startup, dictates what the screen should be if the startup
     *  Screen hasn&#x27;t been set
     */
    constructor.defaultScreen = null;
    /**
     *  Screen to be set by application if it notices that a certain screen should be loaded on startup that is 
     *  different from the default Screen
     */
    constructor.startupScreen = null;
    /**
     *  Callback to be invoked once the application has started and the first screen has been completely loaded
     *  and displayed
     */
    constructor.startupCallback = null;
    /**
     *  Callback invoked during a history load (used in Overlay Manager to open an overlay if it was last history view)
     */
    constructor.loadHistoryCallback = null;
    /**
     *  Array of callbacks that will compare any markers saved in the browser to see if a specific startup screen
     *  should be set. These callbacks should be defined in the screen Java implementation to check if the screen
     *  should be loaded.
     */
    constructor.startupScreenCallbacks = [];
    /**
     *  Function to add startup screen callbacks to the array of callbacks
     *  
     *  @param callback
     *  			callback to add, all callbacks will be invoked on the application startup
     */
    constructor.addStartupScreenCallback = function(callback) {
        ScreenManager.startupScreenCallbacks.unshift(callback);
    };
    /**
     *  Retrieves the current view that corresponds to the Screen Container Element (Should be a screen)
     *  
     *  @return
     *  		EcScreen instance that is currently being shown in the screen container element
     */
    constructor.getCurrentScreen = function() {
        return ViewManager.getView(ScreenManager.SCREEN_CONTAINER_ID);
    };
    /**
     *  Sets the application default Screen that is shown if no startup screen has been defined.
     *  Also sets up some code to run during the application load, that calls the startup callbacks
     *  to see if there is a startup screen different than the defaultScreen, then displays it or the
     *  defaultScreen depending on the results
     *  
     *  @param page
     *  			The default screen that will be displayed if no startup screen is defined during load
     */
    constructor.setDefaultScreen = function(page) {
        ScreenManager.defaultScreen = page;
        $(window.document).ready(function(arg0, arg1) {
            for (var i = 0; i &lt; ScreenManager.startupScreenCallbacks.length; i++) {
                var cb = ScreenManager.startupScreenCallbacks[i];
                cb();
            }
            if (ScreenManager.startupScreen != null) {
                var params = null;
                if (window.document.location.hash.contains(&quot;?&quot;)) {
                    var hashSplit = (window.document.location.hash.split(&quot;?&quot;));
                    if (hashSplit.length &gt; 1 &amp;&amp; hashSplit[1] != &quot;&quot;) {
                        var paramSplit = (hashSplit[1].split(&quot;&amp;&quot;));
                        for (var i = 0; i &lt; paramSplit.length; i++) {
                            var argSplit = (paramSplit[i].split(&quot;=&quot;));
                            if (argSplit.length == 2) 
                                if (params == null) 
                                    params = new Object();
                            (params)[argSplit[0]] = argSplit[1];
                        }
                    }
                }
                ScreenManager.replaceHistory(ScreenManager.startupScreen, ScreenManager.SCREEN_CONTAINER_ID, params);
                ViewManager.showView(ScreenManager.startupScreen, ScreenManager.SCREEN_CONTAINER_ID, function() {
                    ($(ScreenManager.SCREEN_CONTAINER_ID)).foundation();
                });
                return true;
            }
            if (ScreenManager.defaultScreen == null) {
                console.error(&quot;Default Page Not Set, Cannot Start Application&quot;);
                return false;
            }
            var locationHash = window.document.location.hash;
            ScreenManager.replaceScreen(ScreenManager.defaultScreen, function() {
                if (ScreenManager.startupCallback != null) 
                    ScreenManager.startupCallback(locationHash);
            }, null);
            return true;
        });
    };
    /**
     *  Set&#x27;s the current screen, then show&#x27;s it by calling the display function. Depending on the
     *  addHistory flag, will add the page passed in to the history array, tracking session page history
     *  
     *  @param page
     *  			The screen to set as current and display
     *  @param addHistory
     *  			Flag for whether to store this page in the history array
     *  @param callback
     *  			Function to invoke after the page has been displayed and foundation has been set up on the new HTML
     */
    constructor.changeScreen = function(page, callback, params, addHistory) {
        if (addHistory == null) 
            addHistory = true;
        if (addHistory) 
            ScreenManager.addHistory(page, ScreenManager.SCREEN_CONTAINER_ID, params);
        ViewManager.showView(page, ScreenManager.SCREEN_CONTAINER_ID, function() {
            ($(ScreenManager.SCREEN_CONTAINER_ID)).foundation();
            if (callback != null) 
                callback();
        });
    };
    /**
     *  Set&#x27;s the current screen, then show&#x27;s it by calling the display function. This replaces the current HistoryClosure
     *  element for the current screen in the history array, rather than leaving it and (potentially) adding another
     *  history array element like changeScreen
     *  
     *  @param page
     *  			Screen to set as current and display
     *  @param callback
     *  			Function to invoke after the page has been displayed and foundation has been set up on the new HTML
     */
    constructor.replaceScreen = function(page, callback, params) {
        ScreenManager.replaceHistory(page, ScreenManager.SCREEN_CONTAINER_ID, params);
        ViewManager.showView(page, ScreenManager.SCREEN_CONTAINER_ID, function() {
            ($(ScreenManager.SCREEN_CONTAINER_ID)).foundation();
            if (callback != null) 
                callback();
        });
    };
    /**
     *  Reloads the current screen, leaving the history alone
     *  
     *  @param callback
     *  			Function to invoke after the page has been redisplayed and foundation has been set up on the new HTML
     */
    constructor.reloadCurrentScreen = function(callback) {
        ViewManager.showView(ScreenManager.getCurrentScreen(), ScreenManager.SCREEN_CONTAINER_ID, function() {
            ($(ScreenManager.SCREEN_CONTAINER_ID)).foundation();
            if (callback != null) 
                callback();
        });
    };
    /**
     *  Adds the screen passed in and the display container to a HistoryClosure element and pushes it 
     *  on the end of the history cache array. This does not ensure that the screen is displayed though.
     *  
     *  @param screen
     *  			The screen to add to the history cache array
     *  @param displayContainerId
     *  			DOM Element ID corresponding to where the screen will be displayed (likely the SCREEN_CONTAINER_ID)
     */
    constructor.addHistory = function(screen, displayContainerId, params) {
        var name = screen.getDisplayName();
        if (name.equals(&quot;&quot;)) 
            name = screen.displayName;
        if (name.equals(&quot;&quot;)) 
            return;
        var hash = &quot;#&quot; + name;
        if (params != null) {
            hash += &quot;?&quot;;
            for (var str in (params)) {
                if (!hash.endsWith(&quot;?&quot;)) 
                    hash += &quot;&amp;&quot;;
                hash += str + &quot;=&quot; + (params)[str];
            }
        }
        if (hash.endsWith(&quot;?&quot;)) {
            hash = hash.substring(0, hash.length - 1);
        }
        var pageName = name;
        ScreenManager.myHistory[ScreenManager.myHistory.length] = new HistoryClosure(pageName, screen, displayContainerId, params);
        (window.history).pushState({name: pageName}, pageName, hash);
    };
    /**
     *  Replaces the current end of the history array with a new HistoryClosure element that contains the screen and 
     *  containerId passed in.
     *  
     *  @param screen
     *  			Screen to add to the history element that will replace the last in the history array
     *  @param displayContainerId
     *  			DOM Element ID corresponding to where the screen will be displayed (likely the SCREEN_CONTAINER_ID)
     *  @param params
     *  			Object containing key to value pairs that should be put in the url bar to remember state at this history point
     */
    constructor.replaceHistory = function(screen, displayContainerId, params) {
        var name = screen.getDisplayName();
        if (name.equals(&quot;&quot;)) 
            name = screen.displayName;
        if (name.equals(&quot;&quot;)) 
            return;
        var pageName = name;
        var idx = ScreenManager.myHistory.length - 1;
        if (idx &lt; 0) 
            idx = 0;
        ScreenManager.myHistory[idx] = new HistoryClosure(pageName, screen, displayContainerId, params);
        var hash = &quot;#&quot; + pageName;
        if (params != null) {
            hash += &quot;?&quot;;
            for (var str in (params)) {
                if (!hash.endsWith(&quot;?&quot;)) 
                    hash += &quot;&amp;&quot;;
                hash += str + &quot;=&quot; + (params)[str];
            }
        }
        if (hash.endsWith(&quot;?&quot;)) {
            hash = hash.substring(0, hash.length - 1);
        }
        (window.history).replaceState({name: pageName}, pageName, hash);
    };
    /**
     *  Sets the url parameters on the current page
     *  @param params
     *  		url parameters json object
     */
    constructor.setScreenParameters = function(params) {
        ScreenManager.replaceHistory(ScreenManager.myHistory[ScreenManager.myHistory.length - 1].screen, ScreenManager.SCREEN_CONTAINER_ID, params);
    };
    /**
     *  Searches through the history array for the last screen that was loaded with the name passed in, and then displays
     *  it in the container that it was associated with. If there is no screen in the history, then check
     *  if there is a startupScreen that can be loaded right now, otherwise load the default screen
     *  
     *  @param name
     *  			Name of the screen to search for in the history array
     */
    constructor.loadHistoryScreen = function(name) {
        for (var i = ScreenManager.myHistory.length - 1; i &gt; -1; i--) {
            if (ScreenManager.myHistory[i].pageName == name) {
                if (ScreenManager.myHistory[i].screen != null) {
                    var screen = ScreenManager.myHistory[i].screen;
                    if (ScreenManager.loadHistoryCallback != null) 
                        ScreenManager.loadHistoryCallback(screen, ScreenManager.myHistory[i].screenParameters);
                    ViewManager.showView(screen, ScreenManager.myHistory[i].containerId, function() {
                        ($(ScreenManager.SCREEN_CONTAINER_ID)).foundation();
                    });
                    ScreenManager.myHistory[ScreenManager.myHistory.length] = new HistoryClosure(name, screen, ScreenManager.myHistory[i].containerId, ScreenManager.myHistory[i].screenParameters);
                    return;
                }
            }
        }
        ScreenManager.startupScreen = null;
        for (var i = 0; i &lt; ScreenManager.startupScreenCallbacks.length; i++) {
            var cb = ScreenManager.startupScreenCallbacks[i];
            cb();
        }
        if (ScreenManager.startupScreen != null) 
            ScreenManager.changeScreen(ScreenManager.startupScreen, null, null, false);
        var tempName = ScreenManager.defaultScreen.getDisplayName();
        if (tempName.equals(&quot;&quot;)) 
            tempName = ScreenManager.defaultScreen.displayName;
        if (tempName.equals(&quot;&quot;)) 
            return;
        var defaultName = name;
        if (name.equals(defaultName)) {
            window.history.go(-1 * window.history.length);
        }
    };
}, {myHistory: {name: &quot;Array&quot;, arguments: [&quot;HistoryClosure&quot;]}, LOADING_STARTUP_PAGE: &quot;EcScreen&quot;, defaultScreen: &quot;EcScreen&quot;, startupScreen: &quot;EcScreen&quot;, startupCallback: {name: &quot;Callback1&quot;, arguments: [null]}, loadHistoryCallback: {name: &quot;Callback2&quot;, arguments: [&quot;EcScreen&quot;, &quot;Object&quot;]}, startupScreenCallbacks: {name: &quot;Array&quot;, arguments: [&quot;Callback0&quot;]}, viewMap: {name: &quot;Map&quot;, arguments: [null, &quot;EcView&quot;]}}, {});
(function() {
    $(window).on(&quot;popstate&quot;, function(event, arg1) {
        var state = (event.originalEvent)[&quot;state&quot;];
        if (state != null) {
            var poppedName = (state)[&quot;name&quot;];
            ScreenManager.loadHistoryScreen(poppedName);
        }
        return true;
    });
})();
/**
 *  Subclass of view for an overlay, extends EcScreen because overlays should have a display name that can be used
 *  in the URL bar and in the history so the page can be loaded on back button or startup 
 *  
 *  @author devlin.junker@eduworks.com
 */
var EcOverlay = function() {
    EcScreen.call(this);
};
EcOverlay = stjs.extend(EcOverlay, EcScreen, [], null, {}, {});
/**
 *  View Manager that manages displaying overlay views (views that take over the screen, but can be exited to return to
 *  the previous screen) with a few helper functions for managing overlays
 *  
 *  @author devlin.junker@eduworks.com
 *  (NOT TESTED MUCH YET)
 */
var OverlayManager = function() {
    ScreenManager.call(this);
};
OverlayManager = stjs.extend(OverlayManager, ScreenManager, [], function(constructor, prototype) {
    /**
     *  DOM Selector of the overlay wrapper (Should contain the overlay container and overlay close button)
     */
    constructor.OVERLAY_WRAPPER_ID = &quot;#overlay&quot;;
    /**
     *  DOM Selector of the overlay close button (clicking this should hide the current overlay) 
     */
    constructor.OVERLAY_CLOSE_BTN_ID = &quot;#closeOverlay&quot;;
    /**
     *  DOM Selector of the HTML Element that will display the Overlay&#x27;s HTML
     */
    constructor.OVERLAY_CONTAINER_ID = &quot;#overlayContainer&quot;;
    /**
     *  Used if one of the startupOverlayCallbacks decides that it should be displayed on startup (usually using
     *  the URL to check what should be displayed on start)
     */
    constructor.startupOverlay = null;
    /**
     *  Callbacks that can be defined and run on startup, that should check to see if an overlay should be displayed
     *  immediately when the application starts
     */
    constructor.startupOverlayCallbacks = [];
    /**
     *  Adds a callback to be run on startup that can check if an overlay should be displayed (the callback should
     *  be defined in the overlay)
     *  
     *  @param callback
     *  			callback to be added to the startupOverlayCallbacks list
     */
    constructor.addStartupOverlayCallback = function(callback) {
        OverlayManager.startupOverlayCallbacks.unshift(callback);
    };
    /**
     *  Application flag to check if we&#x27;re currently in an overlay or not
     */
    constructor.inOverlay = false;
    /**
     *  Retrieves the current view that corresponds to the Overlay Container Element (Should be a Overlay)
     *  
     *  @return
     *  		EcModal instance that is currently being shown in the Overlay container element
     */
    constructor.getCurrentOverlay = function() {
        return ViewManager.getView(OverlayManager.OVERLAY_CONTAINER_ID);
    };
    /**
     *  Variable to hold the last screen, this is useful if we follow a chain of overlays and then want to close them,
     *  we&#x27;ll make sure to go back to the last screen that was visible to the user
     */
    constructor.lastScreen = null;
    constructor.lastScreenParams = null;
    /**
     *  Set&#x27;s the current overlay, then show&#x27;s it by calling the display function and unhiding the overlay container.
     *  Depending on the addHistory flag, will add the overlay passed in to the history array 
     *  
     *  @param overlay
     *  			The overlay to set as current and display
     *  @param addHistory
     *  			Flag for whether to store this overlay in the history array
     */
    constructor.showOverlay = function(overlay, addHistory) {
        if (!OverlayManager.inOverlay &amp;&amp; ScreenManager.myHistory[ScreenManager.myHistory.length - 1] != null) {
            OverlayManager.lastScreen = ScreenManager.myHistory[ScreenManager.myHistory.length - 1].screen;
            OverlayManager.lastScreenParams = ScreenManager.myHistory[ScreenManager.myHistory.length - 1].screenParameters;
        }
        if (addHistory == null) 
            addHistory = true;
        if (addHistory) 
            ScreenManager.addHistory(overlay, OverlayManager.OVERLAY_CONTAINER_ID, null);
        ViewManager.showView(overlay, OverlayManager.OVERLAY_CONTAINER_ID, function() {
            ($(window.document)).foundation();
            $(OverlayManager.OVERLAY_WRAPPER_ID).addClass(&quot;active&quot;);
            $(OverlayManager.OVERLAY_WRAPPER_ID).fadeIn();
            OverlayManager.inOverlay = true;
        });
        $(OverlayManager.OVERLAY_CLOSE_BTN_ID).off(&quot;click&quot;);
        $(OverlayManager.OVERLAY_CLOSE_BTN_ID).click(function(arg0, arg1) {
            OverlayManager.hideOverlay();
            return true;
        });
    };
    /**
     *  Hides the overlay container and sets the inOverlay flag to false, adds the last screen to the history array so
     *  there is a chain from initial screen to overlay (could be multiple) to initial screen. This way we can press the
     *  back button and be shown the last overlay.
     */
    constructor.hideOverlay = function() {
        $(OverlayManager.OVERLAY_WRAPPER_ID).fadeOut();
        OverlayManager.inOverlay = false;
        if (ScreenManager.myHistory.length &lt;= 2) 
            OverlayManager.changeScreen(OverlayManager.lastScreen, null, OverlayManager.lastScreenParams, null);
    };
}, {startupOverlay: &quot;EcOverlay&quot;, startupOverlayCallbacks: {name: &quot;Array&quot;, arguments: [{name: &quot;Callback1&quot;, arguments: [null]}]}, lastScreen: &quot;EcScreen&quot;, lastScreenParams: &quot;Object&quot;, myHistory: {name: &quot;Array&quot;, arguments: [&quot;HistoryClosure&quot;]}, LOADING_STARTUP_PAGE: &quot;EcScreen&quot;, defaultScreen: &quot;EcScreen&quot;, startupScreen: &quot;EcScreen&quot;, startupCallback: {name: &quot;Callback1&quot;, arguments: [null]}, loadHistoryCallback: {name: &quot;Callback2&quot;, arguments: [&quot;EcScreen&quot;, &quot;Object&quot;]}, startupScreenCallbacks: {name: &quot;Array&quot;, arguments: [&quot;Callback0&quot;]}, viewMap: {name: &quot;Map&quot;, arguments: [null, &quot;EcView&quot;]}}, {});
(function() {
    $(window).keydown(function(event, arg1) {
        if (event.keyCode == 27 &amp;&amp; OverlayManager.inOverlay) {
            OverlayManager.hideOverlay();
        }
        return true;
    });
    ScreenManager.loadHistoryCallback = function(screen, params) {
        var overlay = screen.as(EcOverlay);
        if (overlay != null &amp;&amp; !OverlayManager.inOverlay) {
            OverlayManager.showOverlay(overlay, false);
        } else if (OverlayManager.inOverlay) {
            OverlayManager.hideOverlay();
            OverlayManager.inOverlay = false;
        }
    };
    ScreenManager.startupCallback = function(locationHash) {
        for (var i = 0; i &lt; OverlayManager.startupOverlayCallbacks.length; i++) {
            var cb = OverlayManager.startupOverlayCallbacks[i];
            cb(locationHash);
        }
        if (OverlayManager.startupOverlay != null) {
            OverlayManager.showOverlay(OverlayManager.startupOverlay, true);
        }
    };
})();

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
